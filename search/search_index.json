{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Interactive interface to display graphs Developer Setup This setup requires at least Python 3.10 It is highly recommended to develop this project inside a python virtual environment (VENV). To get started run the following commands in your favourite shell (on Linux). For further infos how the setup a VENV on Windows see here . python -m venv .venv source .venv/bin/activate pip install -r requirements.txt This Creates a new VENV Activates the VENV. Enter deactivate in your shell to exit the VENV Install all required dependencies After copying the default.toml config file to config.toml and making any neccesarry adjustments, run the application like: python interface/main.py <SUBCOMMAND> Usage Debug Tracking The track command allows to debug the ArUco tracking process. It uses the debug renderer which runs in the same thread as the tracker. python interface/main.py track Camera calibration The calib command allows the user to calibrate the camera with the help of multiple modes to choose from. The AUTO mode creates a calibration renderer which renders a ChArUco board which gets displayed by the projector. The connected camera then uses this projection for calibration. Use this mode with CAUTION as the projector itself can introduce distortions which we want to get rid off in the first place. The SEMI_AUTO mode captures a set of images (in an even interval) automatically. The user has to move around a printed out version of the ChArUco board in the camera's field of view. The captured images get used to calibrate the camara. The MANUAL mode only captures images when the user presses the C key on a keyboard. The ChArUco board has again to be printed out and moved around manually. The data is stored in .data/calib.json regardless of the mode. python interface/main.py calib Marker Generation python interface/main.py gen markers Board Generation python interface/main.py gen board","title":"Home"},{"location":"#interactive-interface-to-display-graphs","text":"","title":"Interactive interface to display graphs"},{"location":"#developer-setup","text":"This setup requires at least Python 3.10 It is highly recommended to develop this project inside a python virtual environment (VENV). To get started run the following commands in your favourite shell (on Linux). For further infos how the setup a VENV on Windows see here . python -m venv .venv source .venv/bin/activate pip install -r requirements.txt This Creates a new VENV Activates the VENV. Enter deactivate in your shell to exit the VENV Install all required dependencies After copying the default.toml config file to config.toml and making any neccesarry adjustments, run the application like: python interface/main.py <SUBCOMMAND>","title":"Developer Setup"},{"location":"#usage","text":"","title":"Usage"},{"location":"#debug-tracking","text":"The track command allows to debug the ArUco tracking process. It uses the debug renderer which runs in the same thread as the tracker. python interface/main.py track","title":"Debug Tracking"},{"location":"#camera-calibration","text":"The calib command allows the user to calibrate the camera with the help of multiple modes to choose from. The AUTO mode creates a calibration renderer which renders a ChArUco board which gets displayed by the projector. The connected camera then uses this projection for calibration. Use this mode with CAUTION as the projector itself can introduce distortions which we want to get rid off in the first place. The SEMI_AUTO mode captures a set of images (in an even interval) automatically. The user has to move around a printed out version of the ChArUco board in the camera's field of view. The captured images get used to calibrate the camara. The MANUAL mode only captures images when the user presses the C key on a keyboard. The ChArUco board has again to be printed out and moved around manually. The data is stored in .data/calib.json regardless of the mode. python interface/main.py calib","title":"Camera calibration"},{"location":"#marker-generation","text":"python interface/main.py gen markers","title":"Marker Generation"},{"location":"#board-generation","text":"python interface/main.py gen board","title":"Board Generation"},{"location":"capture/aruco/","text":"board_from ( cols , rows , dict , marker_length = 0.04 , marker_separation = 0.02 ) Returns a ChArUco chessboard with size cols x rows and dict . Parameters: Name Type Description Default cols int Number of columns. required rows int Number of rows. required dict int Unique ArUco dict identifier. Use with dict_from . required marker_length float Chessboard square side length (normally in meters). 0.04 marker_separation float Marker side length (same unit than marker_length ). 0.02 Returns: Type Description The generated ChArUco chessboard. Source code in interface/capture/aruco.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def board_from ( cols : int , rows : int , dict : int , marker_length : float = 0.04 , marker_separation : float = 0.02 ): ''' Returns a ChArUco chessboard with size `cols` x `rows` and `dict`. Args: cols: Number of columns. rows: Number of rows. dict: Unique ArUco dict identifier. Use with `dict_from`. marker_length: Chessboard square side length (normally in meters). marker_separation: Marker side length (same unit than `marker_length`). Returns: The generated ChArUco chessboard. ''' return cv . aruco . CharucoBoard_create ( cols , rows , marker_length , marker_separation , dict ) dict_from ( k ) Returns ArUco dict with 'k' as key. Parameters: Name Type Description Default k str Map key to ArUco dict. required Returns: Type Description Tuple [ int , bool ] The index and True if k exists. -1 and False otherwise. Source code in interface/capture/aruco.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def dict_from ( k : str ) -> Tuple [ int , bool ]: ''' Returns ArUco dict with 'k' as key. Args: k: Map key to ArUco dict. Returns: The index and True if k exists. -1 and False otherwise. ''' if MARKER_MAP [ k ] == None : return - 1 , False return MARKER_MAP [ k ], True type_from ( res , uniq ) Returns a ArUco type string in the form {RES}X{RES}_{UNIQ}. Parameters: Name Type Description Default res int Resolution (X and Y), e.g. 5X5. required uniq int Possible number of unique markers. required Returns: Type Description str Formatted ArUco type string Source code in interface/capture/aruco.py 24 25 26 27 28 29 30 31 32 33 34 35 def type_from ( res : int , uniq : int ) -> str : ''' Returns a ArUco type string in the form {RES}X{RES}_{UNIQ}. Args: res: Resolution (X and Y), e.g. 5X5. uniq: Possible number of unique markers. Returns: Formatted ArUco type string ''' return f ' { res } X { res } _ { uniq } '","title":"Aruco"},{"location":"capture/aruco/#interface.capture.aruco.board_from","text":"Returns a ChArUco chessboard with size cols x rows and dict . Parameters: Name Type Description Default cols int Number of columns. required rows int Number of rows. required dict int Unique ArUco dict identifier. Use with dict_from . required marker_length float Chessboard square side length (normally in meters). 0.04 marker_separation float Marker side length (same unit than marker_length ). 0.02 Returns: Type Description The generated ChArUco chessboard. Source code in interface/capture/aruco.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def board_from ( cols : int , rows : int , dict : int , marker_length : float = 0.04 , marker_separation : float = 0.02 ): ''' Returns a ChArUco chessboard with size `cols` x `rows` and `dict`. Args: cols: Number of columns. rows: Number of rows. dict: Unique ArUco dict identifier. Use with `dict_from`. marker_length: Chessboard square side length (normally in meters). marker_separation: Marker side length (same unit than `marker_length`). Returns: The generated ChArUco chessboard. ''' return cv . aruco . CharucoBoard_create ( cols , rows , marker_length , marker_separation , dict )","title":"board_from()"},{"location":"capture/aruco/#interface.capture.aruco.dict_from","text":"Returns ArUco dict with 'k' as key. Parameters: Name Type Description Default k str Map key to ArUco dict. required Returns: Type Description Tuple [ int , bool ] The index and True if k exists. -1 and False otherwise. Source code in interface/capture/aruco.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def dict_from ( k : str ) -> Tuple [ int , bool ]: ''' Returns ArUco dict with 'k' as key. Args: k: Map key to ArUco dict. Returns: The index and True if k exists. -1 and False otherwise. ''' if MARKER_MAP [ k ] == None : return - 1 , False return MARKER_MAP [ k ], True","title":"dict_from()"},{"location":"capture/aruco/#interface.capture.aruco.type_from","text":"Returns a ArUco type string in the form {RES}X{RES}_{UNIQ}. Parameters: Name Type Description Default res int Resolution (X and Y), e.g. 5X5. required uniq int Possible number of unique markers. required Returns: Type Description str Formatted ArUco type string Source code in interface/capture/aruco.py 24 25 26 27 28 29 30 31 32 33 34 35 def type_from ( res : int , uniq : int ) -> str : ''' Returns a ArUco type string in the form {RES}X{RES}_{UNIQ}. Args: res: Resolution (X and Y), e.g. 5X5. uniq: Possible number of unique markers. Returns: Formatted ArUco type string ''' return f ' { res } X { res } _ { uniq } '","title":"type_from()"},{"location":"capture/calibration/","text":"Calibration This class describes the calibration which is required to calculate the intrisic camera matrix to apply a projection transform when rendering. Source code in interface/capture/calibration.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class Calibration : ''' This class describes the calibration which is required to calculate the intrisic camera matrix to apply a projection transform when rendering. ''' def __init__ ( self , cfg : config . Config , verbose : bool = False ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) cols = cfg [ 'capture' ][ 'calibration' ][ 'cols' ] + 1 rows = cfg [ 'capture' ][ 'calibration' ][ 'rows' ] + 1 # Create ChArUco board self . _board = aruco . board_from ( cols , rows , self . _dict ) self . _min_response = math . floor ((( cols * rows ) / 2 ) * 0.8 ) self . _verbose = verbose self . _cfg = cfg self . _image_size = None self . _corners = [] self . _frames = [] self . _ids = [] def _save_images ( self ): ''' Save the stored frames as images. ''' save_path = os . path . join ( self . _cfg [ 'path' ], 'images' ) if not os . path . exists ( save_path ): os . makedirs ( save_path ) for i , frame in enumerate ( self . _frames ): img_name = 'img- {:02d} .png' . format ( i ) img_path = os . path . join ( save_path , img_name ) cv . imwrite ( img_path , frame ) def _capture ( self , grayscale : bool = False ) -> Error : ''' Capture images from camera and save them afterwards. Args: grayscale: If the captured images should be grayscaled. Returns: An Error if an error was encountered, None if otherwise. ''' cap = cv . VideoCapture ( self . _cfg [ 'capture' ][ 'camera_id' ]) n = 0 while n < self . _cfg [ 'capture' ][ 'calibration' ][ 'number_images' ]: if self . _verbose : click . echo ( 'Capture image {:02d} ' . format ( n )) ok , frame = cap . read () if not ok : return Error ( 'Failed to read the frame' ) if grayscale : frame = cv . cvtColor ( frame , cv . COLOR_BGR2GRAY ) self . _frames . append ( frame ) n += 1 time . sleep ( self . _cfg [ 'capture' ][ 'calibration' ][ 'interval' ]) cap . release () return None def _detect ( self ) -> Error : ''' Detect markers and interpolate the ChArUco board corners. Returns: An Error if an error was encountered, None if otherwise. ''' for frame in self . _frames : # First detect ArUco markers in the current frame corners , ids , _ = cv . aruco . detectMarkers ( frame , self . _dict ) # Skip if we didn't find any corners if len ( corners ) == 0 : continue # Get the ChArUco board corners based on the previously detected markers response , charuco_corners , charuco_ids = cv . aruco . interpolateCornersCharuco ( corners , ids , frame , self . _board ) # If we found at least 80 percent of the total markers we store the ChArUco corners and IDs if response > self . _min_response : self . _corners . append ( charuco_corners ) self . _ids . append ( charuco_ids ) self . _image_size = frame . shape [:: - 1 ] return None # TODO (Techassi): Add option to preview the image used and draw the detected markers return Error ( 'Failed to detect markers in any of the captured frames' ) def _calibrate ( self ) -> CharucoCalibrationData : ''' Calibrate the camera based on the detected ChArUco board. Returns: A tuple consisting of the camera matrix, distortion coefficients, rotation and tranlation vectors. ''' # Extract the camera matrix and distortion coefficients _ , cameraMatrix , distCoeffs , rvecs , tvecs = cv . aruco . calibrateCameraCharuco ( self . _corners , self . _ids , self . _board , self . _image_size , cameraMatrix = None , distCoeffs = None ) return ( cameraMatrix , distCoeffs , rvecs , tvecs ) def _calibrate_auto ( self ) -> Result [ CharucoCalibrationData , Error ]: ''' Automatically calibrate the camera and projector setup. Returns: A result consisting of CharucoCalibrationData or an Error. ''' # Setup calibration renderer and start to render r = 0 # Capture a set of frames from the capture device (camera) err = self . _capture ( True ) if err != None : return Err ( err ) # Next detect ArUco markers and ChArUco board err = self . _detect () if err != None : return Err ( err ) data = self . _calibrate () return Ok ( data ) def _calibrate_semi ( self ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera semi-automatic. This is done by capturing multiple images at an even interval while the user moves the ChArUco board manually. Returns: A result consisting of CharucoCalibrationData or an Error. ''' # First capture a set of frames from the capture device (camera) err = self . _capture ( True ) if err != None : return Err ( err ) # Next detect ArUco markers and ChArUco board err = self . _detect () if err != None : return Err ( err ) data = self . _calibrate () return Ok ( data ) def _calibrate_manual ( self ): ''' Calibrate the camera manually by capturing a specified number of images. ''' self . _capture_manual () def calibrate ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' match mode : case CalibrationMode . AUTO : return self . _calibrate_auto () case CalibrationMode . SEMI_AUTO : return self . _calibrate_semi () case CalibrationMode . MANUAL : return self . _calibrate_manual () case _ : return Err ( Error ( 'Invalid calibration mode' )) def calibrate_save ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' result = self . calibrate ( mode ) if result . is_err (): return result file_path = os . path . join ( self . _cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) err = dump_calibration_result ( file_path , result . unwrap ()) if err != None : return Err ( err ) return result calibrate ( mode = CalibrationMode . AUTO ) Calibrate the camera via the provided calibration mode. Parameters: Name Type Description Default mode CalibrationMode Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. CalibrationMode.AUTO Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def calibrate ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' match mode : case CalibrationMode . AUTO : return self . _calibrate_auto () case CalibrationMode . SEMI_AUTO : return self . _calibrate_semi () case CalibrationMode . MANUAL : return self . _calibrate_manual () case _ : return Err ( Error ( 'Invalid calibration mode' )) calibrate_save ( mode = CalibrationMode . AUTO ) Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Parameters: Name Type Description Default mode CalibrationMode Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. CalibrationMode.AUTO Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def calibrate_save ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' result = self . calibrate ( mode ) if result . is_err (): return result file_path = os . path . join ( self . _cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) err = dump_calibration_result ( file_path , result . unwrap ()) if err != None : return Err ( err ) return result dump_calibration_result ( path , data ) Dump the provided ChArUco calibration result as a pickle file. Parameters: Name Type Description Default path str Path where the calibration data pickle file should be stored. required data CharucoCalibrationData The ChArUco calibration result. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/calibration.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def dump_calibration_result ( path : str , data : CharucoCalibrationData ) -> Error : ''' Dump the provided ChArUco calibration result as a pickle file. Args: path: Path where the calibration data pickle file should be stored. data: The ChArUco calibration result. Returns: An Error if an error was encountered, None if otherwise. ''' try : file = open ( path , 'wb' ) pickle . dump ( data , file ) file . close () return None except : return Error ( 'Failed to dump calibration data' ) read_calibration_result ( path ) Read ChArUco calibration result data from a JSON formatted file at 'path'. Parameters: Name Type Description Default path str Path to the calibration data pickle file. required Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def read_calibration_result ( path : str ) -> Result [ CharucoCalibrationData , Error ]: ''' Read ChArUco calibration result data from a JSON formatted file at 'path'. Args: path: Path to the calibration data pickle file. Returns: A result consisting of CharucoCalibrationData or an Error. ''' try : file = open ( path , 'rb' ) result = pickle . load ( file ) return Ok ( result ) except : return Err ( Error ( 'Failed to read calibration data' ))","title":"Calibration"},{"location":"capture/calibration/#interface.capture.calibration.Calibration","text":"This class describes the calibration which is required to calculate the intrisic camera matrix to apply a projection transform when rendering. Source code in interface/capture/calibration.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class Calibration : ''' This class describes the calibration which is required to calculate the intrisic camera matrix to apply a projection transform when rendering. ''' def __init__ ( self , cfg : config . Config , verbose : bool = False ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) cols = cfg [ 'capture' ][ 'calibration' ][ 'cols' ] + 1 rows = cfg [ 'capture' ][ 'calibration' ][ 'rows' ] + 1 # Create ChArUco board self . _board = aruco . board_from ( cols , rows , self . _dict ) self . _min_response = math . floor ((( cols * rows ) / 2 ) * 0.8 ) self . _verbose = verbose self . _cfg = cfg self . _image_size = None self . _corners = [] self . _frames = [] self . _ids = [] def _save_images ( self ): ''' Save the stored frames as images. ''' save_path = os . path . join ( self . _cfg [ 'path' ], 'images' ) if not os . path . exists ( save_path ): os . makedirs ( save_path ) for i , frame in enumerate ( self . _frames ): img_name = 'img- {:02d} .png' . format ( i ) img_path = os . path . join ( save_path , img_name ) cv . imwrite ( img_path , frame ) def _capture ( self , grayscale : bool = False ) -> Error : ''' Capture images from camera and save them afterwards. Args: grayscale: If the captured images should be grayscaled. Returns: An Error if an error was encountered, None if otherwise. ''' cap = cv . VideoCapture ( self . _cfg [ 'capture' ][ 'camera_id' ]) n = 0 while n < self . _cfg [ 'capture' ][ 'calibration' ][ 'number_images' ]: if self . _verbose : click . echo ( 'Capture image {:02d} ' . format ( n )) ok , frame = cap . read () if not ok : return Error ( 'Failed to read the frame' ) if grayscale : frame = cv . cvtColor ( frame , cv . COLOR_BGR2GRAY ) self . _frames . append ( frame ) n += 1 time . sleep ( self . _cfg [ 'capture' ][ 'calibration' ][ 'interval' ]) cap . release () return None def _detect ( self ) -> Error : ''' Detect markers and interpolate the ChArUco board corners. Returns: An Error if an error was encountered, None if otherwise. ''' for frame in self . _frames : # First detect ArUco markers in the current frame corners , ids , _ = cv . aruco . detectMarkers ( frame , self . _dict ) # Skip if we didn't find any corners if len ( corners ) == 0 : continue # Get the ChArUco board corners based on the previously detected markers response , charuco_corners , charuco_ids = cv . aruco . interpolateCornersCharuco ( corners , ids , frame , self . _board ) # If we found at least 80 percent of the total markers we store the ChArUco corners and IDs if response > self . _min_response : self . _corners . append ( charuco_corners ) self . _ids . append ( charuco_ids ) self . _image_size = frame . shape [:: - 1 ] return None # TODO (Techassi): Add option to preview the image used and draw the detected markers return Error ( 'Failed to detect markers in any of the captured frames' ) def _calibrate ( self ) -> CharucoCalibrationData : ''' Calibrate the camera based on the detected ChArUco board. Returns: A tuple consisting of the camera matrix, distortion coefficients, rotation and tranlation vectors. ''' # Extract the camera matrix and distortion coefficients _ , cameraMatrix , distCoeffs , rvecs , tvecs = cv . aruco . calibrateCameraCharuco ( self . _corners , self . _ids , self . _board , self . _image_size , cameraMatrix = None , distCoeffs = None ) return ( cameraMatrix , distCoeffs , rvecs , tvecs ) def _calibrate_auto ( self ) -> Result [ CharucoCalibrationData , Error ]: ''' Automatically calibrate the camera and projector setup. Returns: A result consisting of CharucoCalibrationData or an Error. ''' # Setup calibration renderer and start to render r = 0 # Capture a set of frames from the capture device (camera) err = self . _capture ( True ) if err != None : return Err ( err ) # Next detect ArUco markers and ChArUco board err = self . _detect () if err != None : return Err ( err ) data = self . _calibrate () return Ok ( data ) def _calibrate_semi ( self ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera semi-automatic. This is done by capturing multiple images at an even interval while the user moves the ChArUco board manually. Returns: A result consisting of CharucoCalibrationData or an Error. ''' # First capture a set of frames from the capture device (camera) err = self . _capture ( True ) if err != None : return Err ( err ) # Next detect ArUco markers and ChArUco board err = self . _detect () if err != None : return Err ( err ) data = self . _calibrate () return Ok ( data ) def _calibrate_manual ( self ): ''' Calibrate the camera manually by capturing a specified number of images. ''' self . _capture_manual () def calibrate ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' match mode : case CalibrationMode . AUTO : return self . _calibrate_auto () case CalibrationMode . SEMI_AUTO : return self . _calibrate_semi () case CalibrationMode . MANUAL : return self . _calibrate_manual () case _ : return Err ( Error ( 'Invalid calibration mode' )) def calibrate_save ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' result = self . calibrate ( mode ) if result . is_err (): return result file_path = os . path . join ( self . _cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) err = dump_calibration_result ( file_path , result . unwrap ()) if err != None : return Err ( err ) return result","title":"Calibration"},{"location":"capture/calibration/#interface.capture.calibration.Calibration.calibrate","text":"Calibrate the camera via the provided calibration mode. Parameters: Name Type Description Default mode CalibrationMode Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. CalibrationMode.AUTO Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def calibrate ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' match mode : case CalibrationMode . AUTO : return self . _calibrate_auto () case CalibrationMode . SEMI_AUTO : return self . _calibrate_semi () case CalibrationMode . MANUAL : return self . _calibrate_manual () case _ : return Err ( Error ( 'Invalid calibration mode' ))","title":"calibrate()"},{"location":"capture/calibration/#interface.capture.calibration.Calibration.calibrate_save","text":"Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Parameters: Name Type Description Default mode CalibrationMode Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. CalibrationMode.AUTO Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def calibrate_save ( self , mode : CalibrationMode = CalibrationMode . AUTO ) -> Result [ CharucoCalibrationData , Error ]: ''' Calibrate the camera via the provided calibration mode. This method additionally saves the calibration data in the .data/calib.json file. Args: mode: Calibration mode. Can be AUTO, SEMI_AUTO or MANUAL. Returns: A result consisting of CharucoCalibrationData or an Error. ''' result = self . calibrate ( mode ) if result . is_err (): return result file_path = os . path . join ( self . _cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) err = dump_calibration_result ( file_path , result . unwrap ()) if err != None : return Err ( err ) return result","title":"calibrate_save()"},{"location":"capture/calibration/#interface.capture.calibration.dump_calibration_result","text":"Dump the provided ChArUco calibration result as a pickle file. Parameters: Name Type Description Default path str Path where the calibration data pickle file should be stored. required data CharucoCalibrationData The ChArUco calibration result. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/calibration.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def dump_calibration_result ( path : str , data : CharucoCalibrationData ) -> Error : ''' Dump the provided ChArUco calibration result as a pickle file. Args: path: Path where the calibration data pickle file should be stored. data: The ChArUco calibration result. Returns: An Error if an error was encountered, None if otherwise. ''' try : file = open ( path , 'wb' ) pickle . dump ( data , file ) file . close () return None except : return Error ( 'Failed to dump calibration data' )","title":"dump_calibration_result()"},{"location":"capture/calibration/#interface.capture.calibration.read_calibration_result","text":"Read ChArUco calibration result data from a JSON formatted file at 'path'. Parameters: Name Type Description Default path str Path to the calibration data pickle file. required Returns: Type Description Result [ CharucoCalibrationData , Error ] A result consisting of CharucoCalibrationData or an Error. Source code in interface/capture/calibration.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def read_calibration_result ( path : str ) -> Result [ CharucoCalibrationData , Error ]: ''' Read ChArUco calibration result data from a JSON formatted file at 'path'. Args: path: Path to the calibration data pickle file. Returns: A result consisting of CharucoCalibrationData or an Error. ''' try : file = open ( path , 'rb' ) result = pickle . load ( file ) return Ok ( result ) except : return Err ( Error ( 'Failed to read calibration data' ))","title":"read_calibration_result()"},{"location":"capture/generator/","text":"BoardGenerator This class generates ArUco chessboard patterns (ChArUco). Source code in interface/capture/generator.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class BoardGenerator (): ''' This class generates ArUco chessboard patterns (ChArUco). ''' def __init__ ( self , cfg : config . Config ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t def generate ( self , cols : int , rows : int , res_width : int , res_height : int ) -> Error : ''' Generate ChArUco board. Args: cols: The number of columns. rows: The number of rows. res_width: Width of the generated image in pixels. res_height: Height of the generated image in pixels. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'boards' ) if not os . path . exists ( path ): os . makedirs ( path ) board = aruco . board_from ( cols + 1 , rows + 1 , self . _dict ) # Construct final path, draw board and save board_path = os . path . join ( path , 'board.png' ) img = board . draw (( res_width , res_height )) cv . imwrite ( board_path , img ) generate ( cols , rows , res_width , res_height ) Generate ChArUco board. Parameters: Name Type Description Default cols int The number of columns. required rows int The number of rows. required res_width int Width of the generated image in pixels. required res_height int Height of the generated image in pixels. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/generator.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def generate ( self , cols : int , rows : int , res_width : int , res_height : int ) -> Error : ''' Generate ChArUco board. Args: cols: The number of columns. rows: The number of rows. res_width: Width of the generated image in pixels. res_height: Height of the generated image in pixels. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'boards' ) if not os . path . exists ( path ): os . makedirs ( path ) board = aruco . board_from ( cols + 1 , rows + 1 , self . _dict ) # Construct final path, draw board and save board_path = os . path . join ( path , 'board.png' ) img = board . draw (( res_width , res_height )) cv . imwrite ( board_path , img ) Generator This class generates ArUco markers / tags. Source code in interface/capture/generator.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Generator : ''' This class generates ArUco markers / tags. ''' def __init__ ( self , cfg : config . Config ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t def generate ( self , number : int , res : int ) -> Error : ''' Generate a variable number of ArUco markers. Args: number: Number of ArUco markers to generate. res: Resolution of the markers in pixels (e.g. 300x300). usage: For which purpose the marker will be used (calibration or as nodes). start_id : The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) if number <= 0 : return Err ( 'Invalid number of markers' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'markers' ) if not os . path . exists ( path ): os . makedirs ( path ) for i in range ( 0 , number ): marker_name = 'marker- {:02d} .png' . format ( i ) # Create a X by Y sized empty 2D array to write the marker to marker = np . zeros (( res , res , 1 ), dtype = 'uint8' ) # Draw the marker in the above created array. The arguments are: # - The selected ArUco dict # - The marker name (ID) # - The resolution, e.g. 300 x 300 pixels # - The array to write the marker into # - The number of border bits cv . aruco . drawMarker ( self . _dict , i , res , marker , 1 ) # Construct file path and save marker_path = os . path . join ( path , marker_name ) ok : bool = False try : ok = cv . imwrite ( marker_path , marker ) except : print ( f 'Error while converting image: { marker_path } ' ) continue if not ok : print ( f 'Error while saving { marker_path } ' ) return None generate ( number , res ) Generate a variable number of ArUco markers. Parameters: Name Type Description Default number int Number of ArUco markers to generate. required res int Resolution of the markers in pixels (e.g. 300x300). required usage For which purpose the marker will be used (calibration or as nodes). required start_id The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/generator.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def generate ( self , number : int , res : int ) -> Error : ''' Generate a variable number of ArUco markers. Args: number: Number of ArUco markers to generate. res: Resolution of the markers in pixels (e.g. 300x300). usage: For which purpose the marker will be used (calibration or as nodes). start_id : The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) if number <= 0 : return Err ( 'Invalid number of markers' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'markers' ) if not os . path . exists ( path ): os . makedirs ( path ) for i in range ( 0 , number ): marker_name = 'marker- {:02d} .png' . format ( i ) # Create a X by Y sized empty 2D array to write the marker to marker = np . zeros (( res , res , 1 ), dtype = 'uint8' ) # Draw the marker in the above created array. The arguments are: # - The selected ArUco dict # - The marker name (ID) # - The resolution, e.g. 300 x 300 pixels # - The array to write the marker into # - The number of border bits cv . aruco . drawMarker ( self . _dict , i , res , marker , 1 ) # Construct file path and save marker_path = os . path . join ( path , marker_name ) ok : bool = False try : ok = cv . imwrite ( marker_path , marker ) except : print ( f 'Error while converting image: { marker_path } ' ) continue if not ok : print ( f 'Error while saving { marker_path } ' ) return None","title":"Generator"},{"location":"capture/generator/#interface.capture.generator.BoardGenerator","text":"This class generates ArUco chessboard patterns (ChArUco). Source code in interface/capture/generator.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class BoardGenerator (): ''' This class generates ArUco chessboard patterns (ChArUco). ''' def __init__ ( self , cfg : config . Config ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t def generate ( self , cols : int , rows : int , res_width : int , res_height : int ) -> Error : ''' Generate ChArUco board. Args: cols: The number of columns. rows: The number of rows. res_width: Width of the generated image in pixels. res_height: Height of the generated image in pixels. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'boards' ) if not os . path . exists ( path ): os . makedirs ( path ) board = aruco . board_from ( cols + 1 , rows + 1 , self . _dict ) # Construct final path, draw board and save board_path = os . path . join ( path , 'board.png' ) img = board . draw (( res_width , res_height )) cv . imwrite ( board_path , img )","title":"BoardGenerator"},{"location":"capture/generator/#interface.capture.generator.BoardGenerator.generate","text":"Generate ChArUco board. Parameters: Name Type Description Default cols int The number of columns. required rows int The number of rows. required res_width int Width of the generated image in pixels. required res_height int Height of the generated image in pixels. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/generator.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def generate ( self , cols : int , rows : int , res_width : int , res_height : int ) -> Error : ''' Generate ChArUco board. Args: cols: The number of columns. rows: The number of rows. res_width: Width of the generated image in pixels. res_height: Height of the generated image in pixels. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'boards' ) if not os . path . exists ( path ): os . makedirs ( path ) board = aruco . board_from ( cols + 1 , rows + 1 , self . _dict ) # Construct final path, draw board and save board_path = os . path . join ( path , 'board.png' ) img = board . draw (( res_width , res_height )) cv . imwrite ( board_path , img )","title":"generate()"},{"location":"capture/generator/#interface.capture.generator.Generator","text":"This class generates ArUco markers / tags. Source code in interface/capture/generator.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Generator : ''' This class generates ArUco markers / tags. ''' def __init__ ( self , cfg : config . Config ) -> None : typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Generator object' ) self . _dict = cv . aruco . Dictionary_get ( t ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t def generate ( self , number : int , res : int ) -> Error : ''' Generate a variable number of ArUco markers. Args: number: Number of ArUco markers to generate. res: Resolution of the markers in pixels (e.g. 300x300). usage: For which purpose the marker will be used (calibration or as nodes). start_id : The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) if number <= 0 : return Err ( 'Invalid number of markers' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'markers' ) if not os . path . exists ( path ): os . makedirs ( path ) for i in range ( 0 , number ): marker_name = 'marker- {:02d} .png' . format ( i ) # Create a X by Y sized empty 2D array to write the marker to marker = np . zeros (( res , res , 1 ), dtype = 'uint8' ) # Draw the marker in the above created array. The arguments are: # - The selected ArUco dict # - The marker name (ID) # - The resolution, e.g. 300 x 300 pixels # - The array to write the marker into # - The number of border bits cv . aruco . drawMarker ( self . _dict , i , res , marker , 1 ) # Construct file path and save marker_path = os . path . join ( path , marker_name ) ok : bool = False try : ok = cv . imwrite ( marker_path , marker ) except : print ( f 'Error while converting image: { marker_path } ' ) continue if not ok : print ( f 'Error while saving { marker_path } ' ) return None","title":"Generator"},{"location":"capture/generator/#interface.capture.generator.Generator.generate","text":"Generate a variable number of ArUco markers. Parameters: Name Type Description Default number int Number of ArUco markers to generate. required res int Resolution of the markers in pixels (e.g. 300x300). required usage For which purpose the marker will be used (calibration or as nodes). required start_id The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/capture/generator.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def generate ( self , number : int , res : int ) -> Error : ''' Generate a variable number of ArUco markers. Args: number: Number of ArUco markers to generate. res: Resolution of the markers in pixels (e.g. 300x300). usage: For which purpose the marker will be used (calibration or as nodes). start_id : The ID (index) to start at. This is usefull when generating calibration and node markers at the same time. This prevents duplicate IDs. Returns: An Error if an error was encountered, None if otherwise. ''' # Make sure the generator was initialized correctly if self . _type == - 1 or self . _dict == None : return Err ( 'Generator initialized with invalid ArUco type' ) if number <= 0 : return Err ( 'Invalid number of markers' ) # Make sure the output folder exists path = os . path . join ( self . _path , 'markers' ) if not os . path . exists ( path ): os . makedirs ( path ) for i in range ( 0 , number ): marker_name = 'marker- {:02d} .png' . format ( i ) # Create a X by Y sized empty 2D array to write the marker to marker = np . zeros (( res , res , 1 ), dtype = 'uint8' ) # Draw the marker in the above created array. The arguments are: # - The selected ArUco dict # - The marker name (ID) # - The resolution, e.g. 300 x 300 pixels # - The array to write the marker into # - The number of border bits cv . aruco . drawMarker ( self . _dict , i , res , marker , 1 ) # Construct file path and save marker_path = os . path . join ( path , marker_name ) ok : bool = False try : ok = cv . imwrite ( marker_path , marker ) except : print ( f 'Error while converting image: { marker_path } ' ) continue if not ok : print ( f 'Error while saving { marker_path } ' ) return None","title":"generate()"},{"location":"capture/tracker/","text":"Tracker This class describes a tracker which is able to track ArUco markers. Source code in interface/capture/tracker.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class Tracker : ''' This class describes a tracker which is able to track ArUco markers. ''' def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData ) -> None : ''' Create a new tracker instance. Args: cfg: Configuration data. calib_data: Camera calibration data. ''' typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) # These values keep track how many frames failed to read self . _max_failed_read = cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] self . _failed_reads = 0 # ArUco marker related values self . _dict = cv . aruco . Dictionary_get ( t ) self . _board = aruco . board_from ( 3 , 3 , self . _dict , marker_length = 0.09 , marker_separation = 0.01 ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t # Tracking self . _delay = fmt . fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . _camera_id = cfg [ 'capture' ][ 'camera_id' ] self . _subscribers : List [ Subscriber ] = [] self . found_rect = False # Current frames self . _color_frame = np . array ([]) self . _frame = np . array ([]) # Dimensions self . _frame_height = 0 self . _frame_width = 0 # Misc self . _calib = calib_data self . _running = False self . _thread = None def _setup ( self ) -> Tuple [ any , any ]: ''' Setup ArUco detection params, capture device and wait delay. Returns: The capture device, ArUco detection params and wait delay. ''' params = cv . aruco . DetectorParameters_create () cap = cv . VideoCapture ( self . _camera_id ) cap . set ( cv . CAP_PROP_AUTOFOCUS , 0 ) cap . set ( cv . CAP_PROP_AUTO_WB , 0 ) cap . set ( cv . CAP_PROP_FRAME_HEIGHT , self . _frame_height ) cap . set ( cv . CAP_PROP_FRAME_WIDTH , self . _frame_width ) # Retrieve frame height and width self . _frame_height = int ( cap . get ( cv . CAP_PROP_FRAME_HEIGHT )) self . _frame_width = int ( cap . get ( cv . CAP_PROP_FRAME_WIDTH )) return cap , params def _is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . _running : return True self . _running = True return False def _transform_markers_to_center ( self , corner_list : CornerList , ids : IDList ) -> MarkerCenterList : ''' This functions transforms the list or corners and the list of IDs into a combined list of tuples consisting of the center position <x,y>, the rotation angle and the ID. Args: corner_list: A list of corners. ids: A list of IDs. Returns: A list of markers. ''' marker_list : MarkerCenterList = [] for i , corners_per_marker in enumerate ( corner_list ): if len ( corners_per_marker [ 0 ]) != 4 : continue center = self . _extract_center_position ( corners_per_marker [ 0 ]) angle = self . _extract_angle ( corners_per_marker [ 0 ], center ) marker_list . append (( center , angle , ids [ i ][ 0 ])) return marker_list def _transform_markers_to_borders ( self , corner_list : CornerList , ids : IDList ) -> MarkerBordersList : ''' This functions transforms the list or corners and the list of IDs into a combined list of tuples consisting of corner positions <x,y>, the center position <x,y>, the rotation angle and the ID. Args: corner_list: A list of corners. ids: A list of IDs. Returns: A list of markers. ''' marker_list : MarkerBordersList = [] for i , corners_per_marker in enumerate ( corner_list ): if len ( corners_per_marker [ 0 ]) != 4 : continue center = self . _extract_center_position ( corners_per_marker [ 0 ]) angle = self . _extract_angle ( corners_per_marker [ 0 ], center ) borders = self . _extract_borders ( corners_per_marker [ 0 ]) marker_list . append (( borders , center , angle , ids [ i ][ 0 ])) return marker_list def _extract_center_position ( self , corners : Corners ) -> Tuple [ int , int ]: ''' Extract the marker center position based on the top-left and bottom-right corner. Args: corners: List or corners. Returns: Marker center position (x,y). ''' center_x = int (( corners [ 0 ][ 0 ] + corners [ 2 ][ 0 ]) / 2 ) center_y = int (( corners [ 0 ][ 1 ] + corners [ 2 ][ 1 ]) / 2 ) return center_x , center_y def _extract_borders ( self , corners : Corners ) -> Tuple [ Tuple [ int , int ], Tuple [ int , int ], Tuple [ int , int ], Tuple [ int , int ] ]: ''' Extract marker corners. Basically this function only converts the position values from floats to integers. Args: corners: List of corners. Returns: A 4-tuple of corner positions (x,y). ''' ( tl , tr , br , bl ) = corners # NOTE (Techassi): This is giga ugly but I don't know of a better way to achieve this return ( int ( tl [ 0 ]), int ( tl [ 1 ])), ( int ( tr [ 0 ]), int ( tr [ 1 ])), ( int ( br [ 0 ]), int ( br [ 1 ])), ( int ( bl [ 0 ]), int ( bl [ 1 ])) def _extract_angle ( self , corners : Corners , center : Tuple [ int , int ]) -> float : ''' Extract the angle from a single marker. The angle gets calculated by first calculating the vector between the center position and the top left corner position. Then we calculate the length to then calculate the unit vector which then can be used to calculate the angle by using arcsin. Args: corners: List of corners. center: Marker center position (x,y). Returns: The calculated angle of the marker. ''' x , y = center [ 0 ] - corners [ 0 ][ 0 ], center [ 1 ] - corners [ 0 ][ 1 ] # Vec from center to top left corner len = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 )) # Calculate length of vec deg = math . degrees ( math . asin ( y / len )) # Use unit vec to calculate angle return deg def _run ( self ) -> Error : ''' Run the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' self . _running = True # Setup video capture and ArUco detection params cap , params = self . _setup () while self . _running : if self . _failed_reads >= self . _max_failed_read : return Err ( 'Too many failed frame reads' ) ok , frame = cap . read () if not ok : # We don't immediatly quit this loop. We return with an # error when the treshold is reached self . _failed_reads += 1 continue self . _color_frame = frame frame = cv . cvtColor ( frame , cv . COLOR_BGR2GRAY ) self . _frame = frame # Detect the markers corners , ids , rejected = cv . aruco . detectMarkers ( frame , self . _dict , parameters = params ) # Refine markers corners , ids , rejected , recovered = cv . aruco . refineDetectedMarkers ( frame , self . _board , corners , ids , rejected , cameraMatrix = self . _calib [ 0 ], distCoeffs = self . _calib [ 1 ] ) if len ( corners ) > 0 : self . notify ( corners , ids , rejected , recovered ) # Cleanup cap . release () def get_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current gray scale frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _frame def get_color_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current color frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _color_frame def start ( self ) -> Error : ''' Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' if self . _is_running (): return Err ( 'Already running' ) # Construct a new thread t = threading . Thread ( None , self . _run , 'tracking-thread' ) self . _thread = t t . start () return None def stop ( self ): ''' Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. ''' if not self . _running : return self . _running = False self . _thread . join () def notify ( self , corners : CornerList , ids : IDList , rejected , recovered ): ''' Notify subscribers with detected markers. Args: corners: A list of corners of detected markers. ids: A list of recovered markers. ''' for sub in self . _subscribers : # If the subription is raw, just pass raw values without any processing if sub [ 0 ]: sub [ 1 ] . put (( corners , ids , rejected , recovered )) else : markers = self . _transform_markers_to_borders ( corners , ids ) sub [ 1 ] . put ( markers ) def subscribe ( self , size : int ) -> Subscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( False , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get def subscribe_raw ( self , size : int ) -> RawSubscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the `subscribe` method. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( True , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get def unsubscribe ( self , index : int ) -> Error : ''' External subscribers can unsubscribe from this tracker. Args: index: The subscription ID. Returns: Non None if an error occured. ''' if index < 0 or index > len ( self . _subscribers ) - 1 : return Err ( 'Invalid index' ) self . _subscribers . pop ( index ) return None __init__ ( cfg , calib_data ) Create a new tracker instance. Parameters: Name Type Description Default cfg Config Configuration data. required calib_data CharucoCalibrationData Camera calibration data. required Source code in interface/capture/tracker.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData ) -> None : ''' Create a new tracker instance. Args: cfg: Configuration data. calib_data: Camera calibration data. ''' typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) # These values keep track how many frames failed to read self . _max_failed_read = cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] self . _failed_reads = 0 # ArUco marker related values self . _dict = cv . aruco . Dictionary_get ( t ) self . _board = aruco . board_from ( 3 , 3 , self . _dict , marker_length = 0.09 , marker_separation = 0.01 ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t # Tracking self . _delay = fmt . fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . _camera_id = cfg [ 'capture' ][ 'camera_id' ] self . _subscribers : List [ Subscriber ] = [] self . found_rect = False # Current frames self . _color_frame = np . array ([]) self . _frame = np . array ([]) # Dimensions self . _frame_height = 0 self . _frame_width = 0 # Misc self . _calib = calib_data self . _running = False self . _thread = None get_color_frame () Get the current color frame from the tracker. Returns: Name Type Description ok bool If current frame is available. frame cv . Mat Current frame. Source code in interface/capture/tracker.py 264 265 266 267 268 269 270 271 272 def get_color_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current color frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _color_frame get_frame () Get the current gray scale frame from the tracker. Returns: Name Type Description ok bool If current frame is available. frame cv . Mat Current frame. Source code in interface/capture/tracker.py 254 255 256 257 258 259 260 261 262 def get_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current gray scale frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _frame notify ( corners , ids , rejected , recovered ) Notify subscribers with detected markers. Parameters: Name Type Description Default corners CornerList A list of corners of detected markers. required ids IDList A list of recovered markers. required Source code in interface/capture/tracker.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def notify ( self , corners : CornerList , ids : IDList , rejected , recovered ): ''' Notify subscribers with detected markers. Args: corners: A list of corners of detected markers. ids: A list of recovered markers. ''' for sub in self . _subscribers : # If the subription is raw, just pass raw values without any processing if sub [ 0 ]: sub [ 1 ] . put (( corners , ids , rejected , recovered )) else : markers = self . _transform_markers_to_borders ( corners , ids ) sub [ 1 ] . put ( markers ) start () Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Type Description Error Non None if an error occured. Source code in interface/capture/tracker.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def start ( self ) -> Error : ''' Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' if self . _is_running (): return Err ( 'Already running' ) # Construct a new thread t = threading . Thread ( None , self . _run , 'tracking-thread' ) self . _thread = t t . start () return None stop () Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. Source code in interface/capture/tracker.py 291 292 293 294 295 296 297 298 299 def stop ( self ): ''' Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. ''' if not self . _running : return self . _running = False self . _thread . join () subscribe ( size ) External consumers can subscribe to this tracker to get real-time marker positions. Returns: Name Type Description subscription Subscription A tuple consisting of the subscription ID, frame widht and height and the retrieve function. Source code in interface/capture/tracker.py 317 318 319 320 321 322 323 324 325 326 327 def subscribe ( self , size : int ) -> Subscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( False , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get subscribe_raw ( size ) External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the subscribe method. Returns: Name Type Description subscription RawSubscription A tuple consisting of the subscription ID, frame widht and height and the retrieve function. Source code in interface/capture/tracker.py 329 330 331 332 333 334 335 336 337 338 339 340 def subscribe_raw ( self , size : int ) -> RawSubscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the `subscribe` method. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( True , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get unsubscribe ( index ) External subscribers can unsubscribe from this tracker. Parameters: Name Type Description Default index int The subscription ID. required Returns: Type Description Error Non None if an error occured. Source code in interface/capture/tracker.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def unsubscribe ( self , index : int ) -> Error : ''' External subscribers can unsubscribe from this tracker. Args: index: The subscription ID. Returns: Non None if an error occured. ''' if index < 0 or index > len ( self . _subscribers ) - 1 : return Err ( 'Invalid index' ) self . _subscribers . pop ( index ) return None","title":"Tracker"},{"location":"capture/tracker/#interface.capture.tracker.Tracker","text":"This class describes a tracker which is able to track ArUco markers. Source code in interface/capture/tracker.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class Tracker : ''' This class describes a tracker which is able to track ArUco markers. ''' def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData ) -> None : ''' Create a new tracker instance. Args: cfg: Configuration data. calib_data: Camera calibration data. ''' typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) # These values keep track how many frames failed to read self . _max_failed_read = cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] self . _failed_reads = 0 # ArUco marker related values self . _dict = cv . aruco . Dictionary_get ( t ) self . _board = aruco . board_from ( 3 , 3 , self . _dict , marker_length = 0.09 , marker_separation = 0.01 ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t # Tracking self . _delay = fmt . fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . _camera_id = cfg [ 'capture' ][ 'camera_id' ] self . _subscribers : List [ Subscriber ] = [] self . found_rect = False # Current frames self . _color_frame = np . array ([]) self . _frame = np . array ([]) # Dimensions self . _frame_height = 0 self . _frame_width = 0 # Misc self . _calib = calib_data self . _running = False self . _thread = None def _setup ( self ) -> Tuple [ any , any ]: ''' Setup ArUco detection params, capture device and wait delay. Returns: The capture device, ArUco detection params and wait delay. ''' params = cv . aruco . DetectorParameters_create () cap = cv . VideoCapture ( self . _camera_id ) cap . set ( cv . CAP_PROP_AUTOFOCUS , 0 ) cap . set ( cv . CAP_PROP_AUTO_WB , 0 ) cap . set ( cv . CAP_PROP_FRAME_HEIGHT , self . _frame_height ) cap . set ( cv . CAP_PROP_FRAME_WIDTH , self . _frame_width ) # Retrieve frame height and width self . _frame_height = int ( cap . get ( cv . CAP_PROP_FRAME_HEIGHT )) self . _frame_width = int ( cap . get ( cv . CAP_PROP_FRAME_WIDTH )) return cap , params def _is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . _running : return True self . _running = True return False def _transform_markers_to_center ( self , corner_list : CornerList , ids : IDList ) -> MarkerCenterList : ''' This functions transforms the list or corners and the list of IDs into a combined list of tuples consisting of the center position <x,y>, the rotation angle and the ID. Args: corner_list: A list of corners. ids: A list of IDs. Returns: A list of markers. ''' marker_list : MarkerCenterList = [] for i , corners_per_marker in enumerate ( corner_list ): if len ( corners_per_marker [ 0 ]) != 4 : continue center = self . _extract_center_position ( corners_per_marker [ 0 ]) angle = self . _extract_angle ( corners_per_marker [ 0 ], center ) marker_list . append (( center , angle , ids [ i ][ 0 ])) return marker_list def _transform_markers_to_borders ( self , corner_list : CornerList , ids : IDList ) -> MarkerBordersList : ''' This functions transforms the list or corners and the list of IDs into a combined list of tuples consisting of corner positions <x,y>, the center position <x,y>, the rotation angle and the ID. Args: corner_list: A list of corners. ids: A list of IDs. Returns: A list of markers. ''' marker_list : MarkerBordersList = [] for i , corners_per_marker in enumerate ( corner_list ): if len ( corners_per_marker [ 0 ]) != 4 : continue center = self . _extract_center_position ( corners_per_marker [ 0 ]) angle = self . _extract_angle ( corners_per_marker [ 0 ], center ) borders = self . _extract_borders ( corners_per_marker [ 0 ]) marker_list . append (( borders , center , angle , ids [ i ][ 0 ])) return marker_list def _extract_center_position ( self , corners : Corners ) -> Tuple [ int , int ]: ''' Extract the marker center position based on the top-left and bottom-right corner. Args: corners: List or corners. Returns: Marker center position (x,y). ''' center_x = int (( corners [ 0 ][ 0 ] + corners [ 2 ][ 0 ]) / 2 ) center_y = int (( corners [ 0 ][ 1 ] + corners [ 2 ][ 1 ]) / 2 ) return center_x , center_y def _extract_borders ( self , corners : Corners ) -> Tuple [ Tuple [ int , int ], Tuple [ int , int ], Tuple [ int , int ], Tuple [ int , int ] ]: ''' Extract marker corners. Basically this function only converts the position values from floats to integers. Args: corners: List of corners. Returns: A 4-tuple of corner positions (x,y). ''' ( tl , tr , br , bl ) = corners # NOTE (Techassi): This is giga ugly but I don't know of a better way to achieve this return ( int ( tl [ 0 ]), int ( tl [ 1 ])), ( int ( tr [ 0 ]), int ( tr [ 1 ])), ( int ( br [ 0 ]), int ( br [ 1 ])), ( int ( bl [ 0 ]), int ( bl [ 1 ])) def _extract_angle ( self , corners : Corners , center : Tuple [ int , int ]) -> float : ''' Extract the angle from a single marker. The angle gets calculated by first calculating the vector between the center position and the top left corner position. Then we calculate the length to then calculate the unit vector which then can be used to calculate the angle by using arcsin. Args: corners: List of corners. center: Marker center position (x,y). Returns: The calculated angle of the marker. ''' x , y = center [ 0 ] - corners [ 0 ][ 0 ], center [ 1 ] - corners [ 0 ][ 1 ] # Vec from center to top left corner len = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 )) # Calculate length of vec deg = math . degrees ( math . asin ( y / len )) # Use unit vec to calculate angle return deg def _run ( self ) -> Error : ''' Run the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' self . _running = True # Setup video capture and ArUco detection params cap , params = self . _setup () while self . _running : if self . _failed_reads >= self . _max_failed_read : return Err ( 'Too many failed frame reads' ) ok , frame = cap . read () if not ok : # We don't immediatly quit this loop. We return with an # error when the treshold is reached self . _failed_reads += 1 continue self . _color_frame = frame frame = cv . cvtColor ( frame , cv . COLOR_BGR2GRAY ) self . _frame = frame # Detect the markers corners , ids , rejected = cv . aruco . detectMarkers ( frame , self . _dict , parameters = params ) # Refine markers corners , ids , rejected , recovered = cv . aruco . refineDetectedMarkers ( frame , self . _board , corners , ids , rejected , cameraMatrix = self . _calib [ 0 ], distCoeffs = self . _calib [ 1 ] ) if len ( corners ) > 0 : self . notify ( corners , ids , rejected , recovered ) # Cleanup cap . release () def get_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current gray scale frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _frame def get_color_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current color frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _color_frame def start ( self ) -> Error : ''' Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' if self . _is_running (): return Err ( 'Already running' ) # Construct a new thread t = threading . Thread ( None , self . _run , 'tracking-thread' ) self . _thread = t t . start () return None def stop ( self ): ''' Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. ''' if not self . _running : return self . _running = False self . _thread . join () def notify ( self , corners : CornerList , ids : IDList , rejected , recovered ): ''' Notify subscribers with detected markers. Args: corners: A list of corners of detected markers. ids: A list of recovered markers. ''' for sub in self . _subscribers : # If the subription is raw, just pass raw values without any processing if sub [ 0 ]: sub [ 1 ] . put (( corners , ids , rejected , recovered )) else : markers = self . _transform_markers_to_borders ( corners , ids ) sub [ 1 ] . put ( markers ) def subscribe ( self , size : int ) -> Subscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( False , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get def subscribe_raw ( self , size : int ) -> RawSubscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the `subscribe` method. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( True , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get def unsubscribe ( self , index : int ) -> Error : ''' External subscribers can unsubscribe from this tracker. Args: index: The subscription ID. Returns: Non None if an error occured. ''' if index < 0 or index > len ( self . _subscribers ) - 1 : return Err ( 'Invalid index' ) self . _subscribers . pop ( index ) return None","title":"Tracker"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.__init__","text":"Create a new tracker instance. Parameters: Name Type Description Default cfg Config Configuration data. required calib_data CharucoCalibrationData Camera calibration data. required Source code in interface/capture/tracker.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData ) -> None : ''' Create a new tracker instance. Args: cfg: Configuration data. calib_data: Camera calibration data. ''' typ = aruco . type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = aruco . dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) # These values keep track how many frames failed to read self . _max_failed_read = cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] self . _failed_reads = 0 # ArUco marker related values self . _dict = cv . aruco . Dictionary_get ( t ) self . _board = aruco . board_from ( 3 , 3 , self . _dict , marker_length = 0.09 , marker_separation = 0.01 ) self . _path = cfg [ 'capture' ][ 'path' ] self . _type = t # Tracking self . _delay = fmt . fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . _camera_id = cfg [ 'capture' ][ 'camera_id' ] self . _subscribers : List [ Subscriber ] = [] self . found_rect = False # Current frames self . _color_frame = np . array ([]) self . _frame = np . array ([]) # Dimensions self . _frame_height = 0 self . _frame_width = 0 # Misc self . _calib = calib_data self . _running = False self . _thread = None","title":"__init__()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.get_color_frame","text":"Get the current color frame from the tracker. Returns: Name Type Description ok bool If current frame is available. frame cv . Mat Current frame. Source code in interface/capture/tracker.py 264 265 266 267 268 269 270 271 272 def get_color_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current color frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _color_frame","title":"get_color_frame()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.get_frame","text":"Get the current gray scale frame from the tracker. Returns: Name Type Description ok bool If current frame is available. frame cv . Mat Current frame. Source code in interface/capture/tracker.py 254 255 256 257 258 259 260 261 262 def get_frame ( self ) -> Tuple [ bool , cv . Mat ]: ''' Get the current gray scale frame from the tracker. Returns: ok: If current frame is available. frame: Current frame. ''' return self . _frame . any (), self . _frame","title":"get_frame()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.notify","text":"Notify subscribers with detected markers. Parameters: Name Type Description Default corners CornerList A list of corners of detected markers. required ids IDList A list of recovered markers. required Source code in interface/capture/tracker.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def notify ( self , corners : CornerList , ids : IDList , rejected , recovered ): ''' Notify subscribers with detected markers. Args: corners: A list of corners of detected markers. ids: A list of recovered markers. ''' for sub in self . _subscribers : # If the subription is raw, just pass raw values without any processing if sub [ 0 ]: sub [ 1 ] . put (( corners , ids , rejected , recovered )) else : markers = self . _transform_markers_to_borders ( corners , ids ) sub [ 1 ] . put ( markers )","title":"notify()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.start","text":"Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Type Description Error Non None if an error occured. Source code in interface/capture/tracker.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def start ( self ) -> Error : ''' Start the main tracking loop. This sets up the ArUco detection params, the video capture and starts tracking. Returns: Non None if an error occured. ''' if self . _is_running (): return Err ( 'Already running' ) # Construct a new thread t = threading . Thread ( None , self . _run , 'tracking-thread' ) self . _thread = t t . start () return None","title":"start()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.stop","text":"Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. Source code in interface/capture/tracker.py 291 292 293 294 295 296 297 298 299 def stop ( self ): ''' Stop the tracker. This stops the tracking loop and joins the thread to wait until it terminates. ''' if not self . _running : return self . _running = False self . _thread . join ()","title":"stop()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.subscribe","text":"External consumers can subscribe to this tracker to get real-time marker positions. Returns: Name Type Description subscription Subscription A tuple consisting of the subscription ID, frame widht and height and the retrieve function. Source code in interface/capture/tracker.py 317 318 319 320 321 322 323 324 325 326 327 def subscribe ( self , size : int ) -> Subscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( False , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get","title":"subscribe()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.subscribe_raw","text":"External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the subscribe method. Returns: Name Type Description subscription RawSubscription A tuple consisting of the subscription ID, frame widht and height and the retrieve function. Source code in interface/capture/tracker.py 329 330 331 332 333 334 335 336 337 338 339 340 def subscribe_raw ( self , size : int ) -> RawSubscription : ''' External consumers can subscribe to this tracker to get real-time marker positions. This returns raw tracking data instead of cleaned data via the `subscribe` method. Returns: subscription: A tuple consisting of the subscription ID, frame widht and height and the retrieve function. ''' q = Queue ( size ) self . _subscribers . append (( True , q )) return len ( self . _subscribers ) - 1 , ( self . _frame_width , self . _frame_height ), q . get","title":"subscribe_raw()"},{"location":"capture/tracker/#interface.capture.tracker.Tracker.unsubscribe","text":"External subscribers can unsubscribe from this tracker. Parameters: Name Type Description Default index int The subscription ID. required Returns: Type Description Error Non None if an error occured. Source code in interface/capture/tracker.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def unsubscribe ( self , index : int ) -> Error : ''' External subscribers can unsubscribe from this tracker. Args: index: The subscription ID. Returns: Non None if an error occured. ''' if index < 0 or index > len ( self . _subscribers ) - 1 : return Err ( 'Invalid index' ) self . _subscribers . pop ( index ) return None","title":"unsubscribe()"},{"location":"client/client/","text":"Client This class describes a HTTP client, which provides methods to easily interact with the REST API. Source code in interface/client/client.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class Client : ''' This class describes a HTTP client, which provides methods to easily interact with the REST API. ''' base_url : str = '' def __init__ ( self , cfg : config . Config ) -> None : ''' Create a new client instance. Args: cfg: The config. ''' if not cfg : raise ValueError self . base_url = fmt . host_port_from ( cfg [ 'backend' ][ 'host' ], cfg [ 'backend' ][ 'port' ] ) def _post ( self , * paths : str , params : dict = {}, data : any = None ): ''' Internal method to create HTTP POST requests. Args: paths: Variable number of path segments. params: A dict of query parameters (Default: {}). data: Request body data (Default: None). Returns: A result object. ''' url = fmt . url_from ( self . base_url , paths ) if not url : return RequestResult ( None , - 1 , 'Unexpected empty URL' , True ) res = requests . post ( url , params = params , data = data ) if res . status_code >= 400 : return RequestResult ( None , res . status_code , 'Unexpected status code' , True ) try : data = res . json () return RequestResult ( data , res . status_code , 'Success' ) except : return RequestResult ( None , res . status_code , 'Response data could not be decoded as JSON' , True ) def _get ( self , * paths : str , params : dict = {}, data : any = None ) -> RequestResult : ''' Internal method to create HTTP GET requests. Args: paths: Variable number of path segments. params: A dict of query parameters (Default: {}). data: Request body data (Default: None). Returns: A result object. ''' url = fmt . url_from ( self . base_url , paths ) if not url : return RequestResult ( None , - 1 , 'Unexpected empty URL' , True ) res = requests . get ( url , params = params , data = data ) if res . status_code >= 400 : return RequestResult ( None , res . status_code , 'Unexpected status code' , True ) try : data = res . json () return RequestResult ( data , res . status_code , 'Success' ) except : return RequestResult ( None , res . status_code , 'Response data could not be decoded as JSON' , True ) def get_graph ( self ) -> Tuple [ Graph , Error ]: ''' Get graph data from the REST API as JSON. Returns: Returns the graph data. If error is not None, an error occured and should be handled. ''' res = self . _get ( 'graphs' ) if res . is_error (): return None , Error ( res . msg ()) data : GraphResponse = res . data () return data [ 'graph' ], None def update_graph ( self , data : Graph ) -> Tuple [ BaseResponse , Error ]: ''' Send updated graph data to the REST API as JSON. Args: data: The updated graph data. Returns: A response indicating the success. ''' if not data : return None , Error ( 'Missing updated graph data' ) res = self . _post ( 'graphs' , data = data ) if res . is_error (): return None , Error ( res . msg ()) return res . data (), None __init__ ( cfg ) Create a new client instance. Parameters: Name Type Description Default cfg config . Config The config. required Source code in interface/client/client.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , cfg : config . Config ) -> None : ''' Create a new client instance. Args: cfg: The config. ''' if not cfg : raise ValueError self . base_url = fmt . host_port_from ( cfg [ 'backend' ][ 'host' ], cfg [ 'backend' ][ 'port' ] ) get_graph () Get graph data from the REST API as JSON. Returns: Type Description Tuple [ Graph , Error ] Returns the graph data. If error is not None, an error occured and should be handled. Source code in interface/client/client.py 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_graph ( self ) -> Tuple [ Graph , Error ]: ''' Get graph data from the REST API as JSON. Returns: Returns the graph data. If error is not None, an error occured and should be handled. ''' res = self . _get ( 'graphs' ) if res . is_error (): return None , Error ( res . msg ()) data : GraphResponse = res . data () return data [ 'graph' ], None update_graph ( data ) Send updated graph data to the REST API as JSON. Parameters: Name Type Description Default data Graph The updated graph data. required Returns: Type Description Tuple [ BaseResponse , Error ] A response indicating the success. Source code in interface/client/client.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def update_graph ( self , data : Graph ) -> Tuple [ BaseResponse , Error ]: ''' Send updated graph data to the REST API as JSON. Args: data: The updated graph data. Returns: A response indicating the success. ''' if not data : return None , Error ( 'Missing updated graph data' ) res = self . _post ( 'graphs' , data = data ) if res . is_error (): return None , Error ( res . msg ()) return res . data (), None","title":"Client"},{"location":"client/client/#interface.client.client.Client","text":"This class describes a HTTP client, which provides methods to easily interact with the REST API. Source code in interface/client/client.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class Client : ''' This class describes a HTTP client, which provides methods to easily interact with the REST API. ''' base_url : str = '' def __init__ ( self , cfg : config . Config ) -> None : ''' Create a new client instance. Args: cfg: The config. ''' if not cfg : raise ValueError self . base_url = fmt . host_port_from ( cfg [ 'backend' ][ 'host' ], cfg [ 'backend' ][ 'port' ] ) def _post ( self , * paths : str , params : dict = {}, data : any = None ): ''' Internal method to create HTTP POST requests. Args: paths: Variable number of path segments. params: A dict of query parameters (Default: {}). data: Request body data (Default: None). Returns: A result object. ''' url = fmt . url_from ( self . base_url , paths ) if not url : return RequestResult ( None , - 1 , 'Unexpected empty URL' , True ) res = requests . post ( url , params = params , data = data ) if res . status_code >= 400 : return RequestResult ( None , res . status_code , 'Unexpected status code' , True ) try : data = res . json () return RequestResult ( data , res . status_code , 'Success' ) except : return RequestResult ( None , res . status_code , 'Response data could not be decoded as JSON' , True ) def _get ( self , * paths : str , params : dict = {}, data : any = None ) -> RequestResult : ''' Internal method to create HTTP GET requests. Args: paths: Variable number of path segments. params: A dict of query parameters (Default: {}). data: Request body data (Default: None). Returns: A result object. ''' url = fmt . url_from ( self . base_url , paths ) if not url : return RequestResult ( None , - 1 , 'Unexpected empty URL' , True ) res = requests . get ( url , params = params , data = data ) if res . status_code >= 400 : return RequestResult ( None , res . status_code , 'Unexpected status code' , True ) try : data = res . json () return RequestResult ( data , res . status_code , 'Success' ) except : return RequestResult ( None , res . status_code , 'Response data could not be decoded as JSON' , True ) def get_graph ( self ) -> Tuple [ Graph , Error ]: ''' Get graph data from the REST API as JSON. Returns: Returns the graph data. If error is not None, an error occured and should be handled. ''' res = self . _get ( 'graphs' ) if res . is_error (): return None , Error ( res . msg ()) data : GraphResponse = res . data () return data [ 'graph' ], None def update_graph ( self , data : Graph ) -> Tuple [ BaseResponse , Error ]: ''' Send updated graph data to the REST API as JSON. Args: data: The updated graph data. Returns: A response indicating the success. ''' if not data : return None , Error ( 'Missing updated graph data' ) res = self . _post ( 'graphs' , data = data ) if res . is_error (): return None , Error ( res . msg ()) return res . data (), None","title":"Client"},{"location":"client/client/#interface.client.client.Client.__init__","text":"Create a new client instance. Parameters: Name Type Description Default cfg config . Config The config. required Source code in interface/client/client.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , cfg : config . Config ) -> None : ''' Create a new client instance. Args: cfg: The config. ''' if not cfg : raise ValueError self . base_url = fmt . host_port_from ( cfg [ 'backend' ][ 'host' ], cfg [ 'backend' ][ 'port' ] )","title":"__init__()"},{"location":"client/client/#interface.client.client.Client.get_graph","text":"Get graph data from the REST API as JSON. Returns: Type Description Tuple [ Graph , Error ] Returns the graph data. If error is not None, an error occured and should be handled. Source code in interface/client/client.py 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_graph ( self ) -> Tuple [ Graph , Error ]: ''' Get graph data from the REST API as JSON. Returns: Returns the graph data. If error is not None, an error occured and should be handled. ''' res = self . _get ( 'graphs' ) if res . is_error (): return None , Error ( res . msg ()) data : GraphResponse = res . data () return data [ 'graph' ], None","title":"get_graph()"},{"location":"client/client/#interface.client.client.Client.update_graph","text":"Send updated graph data to the REST API as JSON. Parameters: Name Type Description Default data Graph The updated graph data. required Returns: Type Description Tuple [ BaseResponse , Error ] A response indicating the success. Source code in interface/client/client.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def update_graph ( self , data : Graph ) -> Tuple [ BaseResponse , Error ]: ''' Send updated graph data to the REST API as JSON. Args: data: The updated graph data. Returns: A response indicating the success. ''' if not data : return None , Error ( 'Missing updated graph data' ) res = self . _post ( 'graphs' , data = data ) if res . is_error (): return None , Error ( res . msg ()) return res . data (), None","title":"update_graph()"},{"location":"cmd/calib/","text":"","title":"Calib"},{"location":"cmd/gen/","text":"","title":"Gen"},{"location":"cmd/root/","text":"calibrate_cmd ( config_path , verbose ) Calibrate the camera in manual mode. Source code in interface/cmd/root.py 67 68 69 70 71 72 73 74 @cli . command ( 'calib' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-v' , '--verbose' , default = False , help = 'Use verbose output' , type = bool , show_default = True ) def calibrate_cmd ( config_path : str , verbose : bool ): ''' Calibrate the camera in manual mode. ''' calib . execute ( config_path , verbose ) gen_board ( config_path , cols , rows , width , height ) Generate ChArUco calibration board. Source code in interface/cmd/root.py 33 34 35 36 37 38 39 40 41 42 43 @gen_group . command ( 'board' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '--cols' , default = 7 , help = 'Number of board columns' , type = int , show_default = True ) @click . option ( '--rows' , default = 5 , help = 'Number of board rows' , type = int , show_default = True ) @click . option ( '-w' , '--width' , default = 1920 , help = 'Width of board in pixels' , type = int , show_default = True ) @click . option ( '-h' , '--height' , default = 1080 , help = 'Height of board in pixels' , type = int , show_default = True ) def gen_board ( config_path : str , cols : int , rows : int , width , height ): ''' Generate ChArUco calibration board. ''' gen . board ( config_path , cols , rows , width , height ) gen_group () Generate tracking related markers or boards. Source code in interface/cmd/root.py 14 15 16 17 18 19 @cli . group ( 'gen' ) def gen_group (): ''' Generate tracking related markers or boards. ''' pass gen_markers ( config_path , number , res ) Generate ArUco tracking markers. Source code in interface/cmd/root.py 22 23 24 25 26 27 28 29 30 @gen_group . command ( 'markers' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-n' , '--number' , default = 10 , help = 'Number of ArUco markers to generate' , type = int , show_default = True ) @click . option ( '-r' , '--res' , default = 300 , help = 'Size of the ArUco marker in pixels' , type = int , show_default = True ) def gen_markers ( config_path : str , number : int , res : int ): ''' Generate ArUco tracking markers. ''' gen . markers ( config_path , number , res ) run_cmd ( config_path , mode ) Run the main application. Source code in interface/cmd/root.py 46 47 48 49 50 51 52 53 @cli . command ( 'run' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-m' , '--mode' , default = 'auto' , help = \"The calibration mode. Can be 'auto', 'semi' or 'manual'\" , type = str , show_default = True ) def run_cmd ( config_path : str , mode : str ): ''' Run the main application. ''' run . execute ( config_path , mode ) track_cmd ( config_path , mode , color ) Run tracking in debug mode. Source code in interface/cmd/root.py 56 57 58 59 60 61 62 63 64 @cli . command ( 'track' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-m' , '--mode' , default = 'auto' , help = \"The calibration mode. Can be 'auto', 'semi' or 'manual'\" , type = str , show_default = True ) @click . option ( '--color' , default = False , help = 'Display the debug renderer in color mode' , type = bool , show_default = True , is_flag = True ) def track_cmd ( config_path : str , mode : str , color : bool ): ''' Run tracking in debug mode. ''' track . execute ( config_path , mode , color )","title":"Root"},{"location":"cmd/root/#interface.cmd.root.calibrate_cmd","text":"Calibrate the camera in manual mode. Source code in interface/cmd/root.py 67 68 69 70 71 72 73 74 @cli . command ( 'calib' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-v' , '--verbose' , default = False , help = 'Use verbose output' , type = bool , show_default = True ) def calibrate_cmd ( config_path : str , verbose : bool ): ''' Calibrate the camera in manual mode. ''' calib . execute ( config_path , verbose )","title":"calibrate_cmd()"},{"location":"cmd/root/#interface.cmd.root.gen_board","text":"Generate ChArUco calibration board. Source code in interface/cmd/root.py 33 34 35 36 37 38 39 40 41 42 43 @gen_group . command ( 'board' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '--cols' , default = 7 , help = 'Number of board columns' , type = int , show_default = True ) @click . option ( '--rows' , default = 5 , help = 'Number of board rows' , type = int , show_default = True ) @click . option ( '-w' , '--width' , default = 1920 , help = 'Width of board in pixels' , type = int , show_default = True ) @click . option ( '-h' , '--height' , default = 1080 , help = 'Height of board in pixels' , type = int , show_default = True ) def gen_board ( config_path : str , cols : int , rows : int , width , height ): ''' Generate ChArUco calibration board. ''' gen . board ( config_path , cols , rows , width , height )","title":"gen_board()"},{"location":"cmd/root/#interface.cmd.root.gen_group","text":"Generate tracking related markers or boards. Source code in interface/cmd/root.py 14 15 16 17 18 19 @cli . group ( 'gen' ) def gen_group (): ''' Generate tracking related markers or boards. ''' pass","title":"gen_group()"},{"location":"cmd/root/#interface.cmd.root.gen_markers","text":"Generate ArUco tracking markers. Source code in interface/cmd/root.py 22 23 24 25 26 27 28 29 30 @gen_group . command ( 'markers' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-n' , '--number' , default = 10 , help = 'Number of ArUco markers to generate' , type = int , show_default = True ) @click . option ( '-r' , '--res' , default = 300 , help = 'Size of the ArUco marker in pixels' , type = int , show_default = True ) def gen_markers ( config_path : str , number : int , res : int ): ''' Generate ArUco tracking markers. ''' gen . markers ( config_path , number , res )","title":"gen_markers()"},{"location":"cmd/root/#interface.cmd.root.run_cmd","text":"Run the main application. Source code in interface/cmd/root.py 46 47 48 49 50 51 52 53 @cli . command ( 'run' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-m' , '--mode' , default = 'auto' , help = \"The calibration mode. Can be 'auto', 'semi' or 'manual'\" , type = str , show_default = True ) def run_cmd ( config_path : str , mode : str ): ''' Run the main application. ''' run . execute ( config_path , mode )","title":"run_cmd()"},{"location":"cmd/root/#interface.cmd.root.track_cmd","text":"Run tracking in debug mode. Source code in interface/cmd/root.py 56 57 58 59 60 61 62 63 64 @cli . command ( 'track' ) @click . option ( '-c' , '--config' , 'config_path' , default = 'config.toml' , help = 'Path to the TOML config file' , type = str , show_default = True ) @click . option ( '-m' , '--mode' , default = 'auto' , help = \"The calibration mode. Can be 'auto', 'semi' or 'manual'\" , type = str , show_default = True ) @click . option ( '--color' , default = False , help = 'Display the debug renderer in color mode' , type = bool , show_default = True , is_flag = True ) def track_cmd ( config_path : str , mode : str , color : bool ): ''' Run tracking in debug mode. ''' track . execute ( config_path , mode , color )","title":"track_cmd()"},{"location":"cmd/run/","text":"","title":"Run"},{"location":"cmd/track/","text":"","title":"Track"},{"location":"config/config/","text":"read_config ( path , auto_validate = False ) Read a TOML file at 'path' and return a new Config class. Parameters: Name Type Description Default path str Path to the TOML config file. required auto_validate bool If this config should be auto validated. False Returns: Type Description Result [ Config , Error ] The decoded config or Error when error occured. Source code in interface/config/config.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def read_config ( path : str , auto_validate : bool = False ) -> Result [ Config , Error ]: ''' Read a TOML file at 'path' and return a new Config class. Args: path: Path to the TOML config file. auto_validate: If this config should be auto validated. Returns: The decoded config or Error when error occured. ''' if not path : return Err ( Error ( 'Invalid/empty path' )) if not os . path . exists ( path ): return Err ( Error ( 'File not found' )) try : config = toml . load ( path , Config ) if not auto_validate : return Ok ( config ) err = validate ( config ) if err != None : return Err ( err ) return Ok ( config ) except toml . TomlDecodeError : return Err ( Error ( 'TOML decode error' )) validate ( cfg ) Validate config values. Returns an error if validation failed. Parameters: Name Type Description Default cfg Config Config to validate. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/config/config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def validate ( cfg : Config ) -> Error : ''' Validate config values. Returns an error if validation failed. Args: cfg: Config to validate. Returns: An Error if an error was encountered, None if otherwise. ''' if not cfg [ 'backend' ][ 'host' ]: return Error ( 'Invalid host' ) if cfg [ 'backend' ][ 'port' ] < 0 or cfg [ 'backend' ][ 'port' ] > 65535 : return Error ( 'Invalid port' ) if cfg [ 'capture' ][ 'camera_id' ] < 0 : return Error ( 'Invalid camera device ID' ) if cfg [ 'capture' ][ 'fps' ] < 0 : return Error ( 'Invalid FPS' ) if not checks . is_in ( cfg [ 'capture' ][ 'aruco' ][ 'uniques' ], ARUCO_ALLOWED_UNIQUES ): return Error ( f 'Invalid ArUco uniques number. Allowed are: { ARUCO_ALLOWED_UNIQUES } ' ) if not checks . is_in ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], ARUCO_ALLOWED_SIZES ): return Error ( f 'Invalid ArUco size. Allowed are: { ARUCO_ALLOWED_SIZES } ' ) if cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] < 0 : return Error ( 'Invalid max failed read amount' ) if cfg [ 'capture' ][ 'calibration' ][ 'number_images' ] <= 0 : return Error ( 'Invalid number of calibration images. Choose value > 0. More than 5 recommended' ) if cfg [ 'capture' ][ 'calibration' ][ 'interval' ] <= 0 : return Error ( 'Invalid calibration interval. Choose value > 0' ) if cfg [ 'capture' ][ 'calibration' ][ 'height' ] < 0 : return Error ( 'Invalid calibration board height' ) if cfg [ 'capture' ][ 'calibration' ][ 'width' ] < 0 : return Error ( 'Invalid calibration board width' ) if cfg [ 'capture' ][ 'calibration' ][ 'rows' ] < 0 : return Error ( 'Invalid calibration board row count' ) if cfg [ 'capture' ][ 'calibration' ][ 'cols' ] < 0 : return Error ( 'Invalid calibration board col count' ) if cfg [ 'renderer' ][ 'transform_interval' ] <= 0 : return Error ( 'Invalid transform interval. Choose value > 0' ) if cfg [ 'renderer' ][ 'height' ] < 0 : return Error ( 'Invalid renderer height' ) if cfg [ 'renderer' ][ 'width' ] < 0 : return Error ( 'Invalid renderer width' ) return None","title":"Config"},{"location":"config/config/#interface.config.config.read_config","text":"Read a TOML file at 'path' and return a new Config class. Parameters: Name Type Description Default path str Path to the TOML config file. required auto_validate bool If this config should be auto validated. False Returns: Type Description Result [ Config , Error ] The decoded config or Error when error occured. Source code in interface/config/config.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def read_config ( path : str , auto_validate : bool = False ) -> Result [ Config , Error ]: ''' Read a TOML file at 'path' and return a new Config class. Args: path: Path to the TOML config file. auto_validate: If this config should be auto validated. Returns: The decoded config or Error when error occured. ''' if not path : return Err ( Error ( 'Invalid/empty path' )) if not os . path . exists ( path ): return Err ( Error ( 'File not found' )) try : config = toml . load ( path , Config ) if not auto_validate : return Ok ( config ) err = validate ( config ) if err != None : return Err ( err ) return Ok ( config ) except toml . TomlDecodeError : return Err ( Error ( 'TOML decode error' ))","title":"read_config()"},{"location":"config/config/#interface.config.config.validate","text":"Validate config values. Returns an error if validation failed. Parameters: Name Type Description Default cfg Config Config to validate. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/config/config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def validate ( cfg : Config ) -> Error : ''' Validate config values. Returns an error if validation failed. Args: cfg: Config to validate. Returns: An Error if an error was encountered, None if otherwise. ''' if not cfg [ 'backend' ][ 'host' ]: return Error ( 'Invalid host' ) if cfg [ 'backend' ][ 'port' ] < 0 or cfg [ 'backend' ][ 'port' ] > 65535 : return Error ( 'Invalid port' ) if cfg [ 'capture' ][ 'camera_id' ] < 0 : return Error ( 'Invalid camera device ID' ) if cfg [ 'capture' ][ 'fps' ] < 0 : return Error ( 'Invalid FPS' ) if not checks . is_in ( cfg [ 'capture' ][ 'aruco' ][ 'uniques' ], ARUCO_ALLOWED_UNIQUES ): return Error ( f 'Invalid ArUco uniques number. Allowed are: { ARUCO_ALLOWED_UNIQUES } ' ) if not checks . is_in ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], ARUCO_ALLOWED_SIZES ): return Error ( f 'Invalid ArUco size. Allowed are: { ARUCO_ALLOWED_SIZES } ' ) if cfg [ 'capture' ][ 'tracker' ][ 'max_failed_read' ] < 0 : return Error ( 'Invalid max failed read amount' ) if cfg [ 'capture' ][ 'calibration' ][ 'number_images' ] <= 0 : return Error ( 'Invalid number of calibration images. Choose value > 0. More than 5 recommended' ) if cfg [ 'capture' ][ 'calibration' ][ 'interval' ] <= 0 : return Error ( 'Invalid calibration interval. Choose value > 0' ) if cfg [ 'capture' ][ 'calibration' ][ 'height' ] < 0 : return Error ( 'Invalid calibration board height' ) if cfg [ 'capture' ][ 'calibration' ][ 'width' ] < 0 : return Error ( 'Invalid calibration board width' ) if cfg [ 'capture' ][ 'calibration' ][ 'rows' ] < 0 : return Error ( 'Invalid calibration board row count' ) if cfg [ 'capture' ][ 'calibration' ][ 'cols' ] < 0 : return Error ( 'Invalid calibration board col count' ) if cfg [ 'renderer' ][ 'transform_interval' ] <= 0 : return Error ( 'Invalid transform interval. Choose value > 0' ) if cfg [ 'renderer' ][ 'height' ] < 0 : return Error ( 'Invalid renderer height' ) if cfg [ 'renderer' ][ 'width' ] < 0 : return Error ( 'Invalid renderer width' ) return None","title":"validate()"},{"location":"renderer/calibration/","text":"","title":"Calibration"},{"location":"renderer/debug/","text":"DebugRenderer Bases: Shared This class decribes a debug renderer used to draw tracking information for debug purposes. Source code in interface/renderer/debug.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class DebugRenderer ( Shared ): ''' This class decribes a debug renderer used to draw tracking information for debug purposes. ''' def __init__ ( self , cfg : Config , tracker : Tracker , use_color : bool ) -> None : super () . __init__ ( cfg , tracker , 'debug-tracking' ) self . _use_color = use_color def _get_frame ( self ) -> Tuple [ bool , cv . Mat ]: '''''' if self . _use_color : return self . tracker . get_color_frame () return self . tracker . get_frame () def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) retrieve = self . subscribe () while self . running : ok , frame = self . _get_frame () if not ok : continue try : markers = retrieve ( False ) for marker in markers : self . draw_borders ( marker [ 0 ], frame ) self . draw_angle ( marker [ 0 ], marker [ 2 ], frame , with_text = False ) self . draw_center_point ( marker [ 1 ], marker [ 3 ], frame ) except : pass cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None start () Start the render loop. Source code in interface/renderer/debug.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) retrieve = self . subscribe () while self . running : ok , frame = self . _get_frame () if not ok : continue try : markers = retrieve ( False ) for marker in markers : self . draw_borders ( marker [ 0 ], frame ) self . draw_angle ( marker [ 0 ], marker [ 2 ], frame , with_text = False ) self . draw_center_point ( marker [ 1 ], marker [ 3 ], frame ) except : pass cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"Debug"},{"location":"renderer/debug/#interface.renderer.debug.DebugRenderer","text":"Bases: Shared This class decribes a debug renderer used to draw tracking information for debug purposes. Source code in interface/renderer/debug.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class DebugRenderer ( Shared ): ''' This class decribes a debug renderer used to draw tracking information for debug purposes. ''' def __init__ ( self , cfg : Config , tracker : Tracker , use_color : bool ) -> None : super () . __init__ ( cfg , tracker , 'debug-tracking' ) self . _use_color = use_color def _get_frame ( self ) -> Tuple [ bool , cv . Mat ]: '''''' if self . _use_color : return self . tracker . get_color_frame () return self . tracker . get_frame () def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) retrieve = self . subscribe () while self . running : ok , frame = self . _get_frame () if not ok : continue try : markers = retrieve ( False ) for marker in markers : self . draw_borders ( marker [ 0 ], frame ) self . draw_angle ( marker [ 0 ], marker [ 2 ], frame , with_text = False ) self . draw_center_point ( marker [ 1 ], marker [ 3 ], frame ) except : pass cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"DebugRenderer"},{"location":"renderer/debug/#interface.renderer.debug.DebugRenderer.start","text":"Start the render loop. Source code in interface/renderer/debug.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) retrieve = self . subscribe () while self . running : ok , frame = self . _get_frame () if not ok : continue try : markers = retrieve ( False ) for marker in markers : self . draw_borders ( marker [ 0 ], frame ) self . draw_angle ( marker [ 0 ], marker [ 2 ], frame , with_text = False ) self . draw_center_point ( marker [ 1 ], marker [ 3 ], frame ) except : pass cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"start()"},{"location":"renderer/renderer/","text":"Renderer Bases: Transformer This class describes the renderer which renders the user interface. Source code in interface/renderer/renderer.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class Renderer ( Transformer ): ''' This class describes the renderer which renders the user interface. ''' def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData , tracker : Tracker ) -> None : super () . __init__ ( cfg , calib_data , tracker ) # Dimensions self . _frame_height = cfg [ 'renderer' ][ 'height' ] self . _frame_width = cfg [ 'renderer' ][ 'width' ] # Objects self . _objects : Dict [ int , RenderObject ] = {} self . _marker_images : List [ cv . Mat ] = [] def _load_aruco_marker_images ( self ): ''' Load all ArUco marker images and save them in a list for future uses. ''' base_path = os . path . join ( self . cfg [ 'capture' ][ 'path' ], 'markers' , '*.png' ) img_paths = sorted ( glob . glob ( base_path )) for img_path in img_paths : mat = cv . imread ( img_path ) self . _marker_images . append ( mat ) def _corner_coords ( self , corner : Corner , mat : cv . Mat , scale : float = 1.0 ) -> Tuple [ int , int ]: ''' Calculate corner coordinates based on the size and scaling of the provided mat. Args: corner: Which corner to calculate. mat: The mat which should be placed. Used for size. scale: The scaling (default: 1.0, no scaling). Returns: A tuple of x, y integer values. ''' match corner : case Corner . TOP_LEFT : return ( 10 , 10 ) case Corner . TOP_RIGHT : return ( 10 , int ( self . _frame_width - mat . shape [ 1 ] * scale ) - 10 ) case Corner . BOTTOM_RIGHT : return ( int ( self . _frame_height - mat . shape [ 0 ] * scale ) - 10 , int ( self . _frame_width - mat . shape [ 1 ] * scale ) - 10 ) case Corner . BOTTOM_LEFT : return ( int ( self . _frame_height - mat . shape [ 0 ] * scale ) - 10 , 10 ) def _prepare_corner_markers ( self ): ''' Read ArUco markers from disk and add them to the render object list at the right positions (in all four corners). ''' # We expect the user to provide the IDs of the corners in the following order: top-left, top-right, bottom-right # and bottom-left # NOTE (Techassi): Don't hardcode the scaling. Add this to the config # Top-left self . add_object_to_layer ( 10 , ArUcoMarker ( 10 , 10 , self . _marker_images [ 0 ], '' , 0.5 )) # Top-right x , y = self . _corner_coords ( Corner . TOP_RIGHT , self . _marker_images [ 1 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 1 ], '' , 0.5 )) # Bottom-right x , y = self . _corner_coords ( Corner . BOTTOM_RIGHT , self . _marker_images [ 2 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 2 ], '' , 0.5 )) # Bottom-left x , y = self . _corner_coords ( Corner . BOTTOM_LEFT , self . _marker_images [ 3 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 3 ], '' , 0.5 )) def _update_markers ( self , markers : MarkerCenterList ): ''' Update the amrker objects in the render tree. Args: markers: List of markers. ''' for marker in markers : if marker [ 2 ] in [ 0 , 1 , 2 , 3 ]: continue result = self . get_object_on_layer_by_index ( 0 , marker [ 2 ]) if result . is_err (): self . add_object_to_layer_at_index ( 0 , marker [ 2 ], Node ( int ( marker [ 0 ][ 0 ] * self . scaling_x ), int ( marker [ 0 ][ 1 ] * self . scaling_y ), 20 , 'test' , COLOR_RED )) else : result . unwrap () . update ( int ( marker [ 0 ][ 0 ] * self . scaling_x ), int ( marker [ 0 ][ 1 ] * self . scaling_y )) def _initialize ( self ): ''' Prepare multiple things before starting the renderer. ''' self . add_render_layer ( 10 , 'corner-markers' , False ) self . add_render_layer ( 0 , 'default' ) self . _load_aruco_marker_images () self . _prepare_corner_markers () cv . namedWindow ( self . window_name , cv . WINDOW_NORMAL ) def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) self . _initialize () retrieve = self . subscribe_raw () # White frame sized width x height initial_frame = 255 * np . ones (( self . _frame_height , self . _frame_width , 3 ), dtype = np . uint8 ) ref_frame = np . copy ( initial_frame ) super () . render ( ref_frame , self . transform_matrix , self . transform_width , self . transform_height ) params = cv . aruco . DetectorParameters_create () markerCorners , markerIds , _ = cv . aruco . detectMarkers ( ref_frame , self . dict , parameters = params ) if len ( markerCorners ) == 4 : ret , charucoCorners , charucoIds = cv . aruco . interpolateCornersCharuco ( markerCorners , markerIds , ref_frame , self . board ) print ( charucoCorners . shape ) cv . namedWindow ( 'reference' , cv . WINDOW_NORMAL ) cv . setWindowProperty ( 'reference' , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) while self . running : cv . imshow ( 'reference' , ref_frame ) try : ( corners , ids , rejected , recovered ) = retrieve ( False ) scaling = self . get_reference_scaling_naive ( corners , ids , self . _frame_width , self . _frame_height ) if len ( scaling ) == 2 : self . scaling_x = scaling [ 0 ] self . scaling_y = scaling [ 1 ] cv . destroyWindow ( 'reference' ) break except Empty : pass except Exception as e : print ( e ) break idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () while self . running : frame = np . copy ( initial_frame ) # First try to retrieve the list of tuples consisting of marker coordinates (position and angle) and IDs. # This can faile, because the retrieval of items from the queue can raise the Empty exception when there # currently is no item in the queue try : ( corners , ids , _ , _ ) = retrieve ( False ) markers = self . tracker . _transform_markers_to_center ( corners , ids ) self . _update_markers ( markers ) except Empty : pass except Exception as e : print ( e ) break super () . render ( frame , self . transform_matrix , self . _frame_width , self . _frame_width ) # frame = cv.warpPerspective(frame, self.transform_matrix, (self._frame_width, self._frame_width)) # print(frame.shape) cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None start () Start the render loop. Source code in interface/renderer/renderer.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) self . _initialize () retrieve = self . subscribe_raw () # White frame sized width x height initial_frame = 255 * np . ones (( self . _frame_height , self . _frame_width , 3 ), dtype = np . uint8 ) ref_frame = np . copy ( initial_frame ) super () . render ( ref_frame , self . transform_matrix , self . transform_width , self . transform_height ) params = cv . aruco . DetectorParameters_create () markerCorners , markerIds , _ = cv . aruco . detectMarkers ( ref_frame , self . dict , parameters = params ) if len ( markerCorners ) == 4 : ret , charucoCorners , charucoIds = cv . aruco . interpolateCornersCharuco ( markerCorners , markerIds , ref_frame , self . board ) print ( charucoCorners . shape ) cv . namedWindow ( 'reference' , cv . WINDOW_NORMAL ) cv . setWindowProperty ( 'reference' , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) while self . running : cv . imshow ( 'reference' , ref_frame ) try : ( corners , ids , rejected , recovered ) = retrieve ( False ) scaling = self . get_reference_scaling_naive ( corners , ids , self . _frame_width , self . _frame_height ) if len ( scaling ) == 2 : self . scaling_x = scaling [ 0 ] self . scaling_y = scaling [ 1 ] cv . destroyWindow ( 'reference' ) break except Empty : pass except Exception as e : print ( e ) break idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () while self . running : frame = np . copy ( initial_frame ) # First try to retrieve the list of tuples consisting of marker coordinates (position and angle) and IDs. # This can faile, because the retrieval of items from the queue can raise the Empty exception when there # currently is no item in the queue try : ( corners , ids , _ , _ ) = retrieve ( False ) markers = self . tracker . _transform_markers_to_center ( corners , ids ) self . _update_markers ( markers ) except Empty : pass except Exception as e : print ( e ) break super () . render ( frame , self . transform_matrix , self . _frame_width , self . _frame_width ) # frame = cv.warpPerspective(frame, self.transform_matrix, (self._frame_width, self._frame_width)) # print(frame.shape) cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"Renderer"},{"location":"renderer/renderer/#interface.renderer.renderer.Renderer","text":"Bases: Transformer This class describes the renderer which renders the user interface. Source code in interface/renderer/renderer.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class Renderer ( Transformer ): ''' This class describes the renderer which renders the user interface. ''' def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData , tracker : Tracker ) -> None : super () . __init__ ( cfg , calib_data , tracker ) # Dimensions self . _frame_height = cfg [ 'renderer' ][ 'height' ] self . _frame_width = cfg [ 'renderer' ][ 'width' ] # Objects self . _objects : Dict [ int , RenderObject ] = {} self . _marker_images : List [ cv . Mat ] = [] def _load_aruco_marker_images ( self ): ''' Load all ArUco marker images and save them in a list for future uses. ''' base_path = os . path . join ( self . cfg [ 'capture' ][ 'path' ], 'markers' , '*.png' ) img_paths = sorted ( glob . glob ( base_path )) for img_path in img_paths : mat = cv . imread ( img_path ) self . _marker_images . append ( mat ) def _corner_coords ( self , corner : Corner , mat : cv . Mat , scale : float = 1.0 ) -> Tuple [ int , int ]: ''' Calculate corner coordinates based on the size and scaling of the provided mat. Args: corner: Which corner to calculate. mat: The mat which should be placed. Used for size. scale: The scaling (default: 1.0, no scaling). Returns: A tuple of x, y integer values. ''' match corner : case Corner . TOP_LEFT : return ( 10 , 10 ) case Corner . TOP_RIGHT : return ( 10 , int ( self . _frame_width - mat . shape [ 1 ] * scale ) - 10 ) case Corner . BOTTOM_RIGHT : return ( int ( self . _frame_height - mat . shape [ 0 ] * scale ) - 10 , int ( self . _frame_width - mat . shape [ 1 ] * scale ) - 10 ) case Corner . BOTTOM_LEFT : return ( int ( self . _frame_height - mat . shape [ 0 ] * scale ) - 10 , 10 ) def _prepare_corner_markers ( self ): ''' Read ArUco markers from disk and add them to the render object list at the right positions (in all four corners). ''' # We expect the user to provide the IDs of the corners in the following order: top-left, top-right, bottom-right # and bottom-left # NOTE (Techassi): Don't hardcode the scaling. Add this to the config # Top-left self . add_object_to_layer ( 10 , ArUcoMarker ( 10 , 10 , self . _marker_images [ 0 ], '' , 0.5 )) # Top-right x , y = self . _corner_coords ( Corner . TOP_RIGHT , self . _marker_images [ 1 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 1 ], '' , 0.5 )) # Bottom-right x , y = self . _corner_coords ( Corner . BOTTOM_RIGHT , self . _marker_images [ 2 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 2 ], '' , 0.5 )) # Bottom-left x , y = self . _corner_coords ( Corner . BOTTOM_LEFT , self . _marker_images [ 3 ], 0.5 ) self . add_object_to_layer ( 10 , ArUcoMarker ( y , x , self . _marker_images [ 3 ], '' , 0.5 )) def _update_markers ( self , markers : MarkerCenterList ): ''' Update the amrker objects in the render tree. Args: markers: List of markers. ''' for marker in markers : if marker [ 2 ] in [ 0 , 1 , 2 , 3 ]: continue result = self . get_object_on_layer_by_index ( 0 , marker [ 2 ]) if result . is_err (): self . add_object_to_layer_at_index ( 0 , marker [ 2 ], Node ( int ( marker [ 0 ][ 0 ] * self . scaling_x ), int ( marker [ 0 ][ 1 ] * self . scaling_y ), 20 , 'test' , COLOR_RED )) else : result . unwrap () . update ( int ( marker [ 0 ][ 0 ] * self . scaling_x ), int ( marker [ 0 ][ 1 ] * self . scaling_y )) def _initialize ( self ): ''' Prepare multiple things before starting the renderer. ''' self . add_render_layer ( 10 , 'corner-markers' , False ) self . add_render_layer ( 0 , 'default' ) self . _load_aruco_marker_images () self . _prepare_corner_markers () cv . namedWindow ( self . window_name , cv . WINDOW_NORMAL ) def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) self . _initialize () retrieve = self . subscribe_raw () # White frame sized width x height initial_frame = 255 * np . ones (( self . _frame_height , self . _frame_width , 3 ), dtype = np . uint8 ) ref_frame = np . copy ( initial_frame ) super () . render ( ref_frame , self . transform_matrix , self . transform_width , self . transform_height ) params = cv . aruco . DetectorParameters_create () markerCorners , markerIds , _ = cv . aruco . detectMarkers ( ref_frame , self . dict , parameters = params ) if len ( markerCorners ) == 4 : ret , charucoCorners , charucoIds = cv . aruco . interpolateCornersCharuco ( markerCorners , markerIds , ref_frame , self . board ) print ( charucoCorners . shape ) cv . namedWindow ( 'reference' , cv . WINDOW_NORMAL ) cv . setWindowProperty ( 'reference' , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) while self . running : cv . imshow ( 'reference' , ref_frame ) try : ( corners , ids , rejected , recovered ) = retrieve ( False ) scaling = self . get_reference_scaling_naive ( corners , ids , self . _frame_width , self . _frame_height ) if len ( scaling ) == 2 : self . scaling_x = scaling [ 0 ] self . scaling_y = scaling [ 1 ] cv . destroyWindow ( 'reference' ) break except Empty : pass except Exception as e : print ( e ) break idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () while self . running : frame = np . copy ( initial_frame ) # First try to retrieve the list of tuples consisting of marker coordinates (position and angle) and IDs. # This can faile, because the retrieval of items from the queue can raise the Empty exception when there # currently is no item in the queue try : ( corners , ids , _ , _ ) = retrieve ( False ) markers = self . tracker . _transform_markers_to_center ( corners , ids ) self . _update_markers ( markers ) except Empty : pass except Exception as e : print ( e ) break super () . render ( frame , self . transform_matrix , self . _frame_width , self . _frame_width ) # frame = cv.warpPerspective(frame, self.transform_matrix, (self._frame_width, self._frame_width)) # print(frame.shape) cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"Renderer"},{"location":"renderer/renderer/#interface.renderer.renderer.Renderer.start","text":"Start the render loop. Source code in interface/renderer/renderer.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def start ( self ) -> Error : ''' Start the render loop. ''' if self . is_running (): return Error ( 'Already running' ) self . _initialize () retrieve = self . subscribe_raw () # White frame sized width x height initial_frame = 255 * np . ones (( self . _frame_height , self . _frame_width , 3 ), dtype = np . uint8 ) ref_frame = np . copy ( initial_frame ) super () . render ( ref_frame , self . transform_matrix , self . transform_width , self . transform_height ) params = cv . aruco . DetectorParameters_create () markerCorners , markerIds , _ = cv . aruco . detectMarkers ( ref_frame , self . dict , parameters = params ) if len ( markerCorners ) == 4 : ret , charucoCorners , charucoIds = cv . aruco . interpolateCornersCharuco ( markerCorners , markerIds , ref_frame , self . board ) print ( charucoCorners . shape ) cv . namedWindow ( 'reference' , cv . WINDOW_NORMAL ) cv . setWindowProperty ( 'reference' , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) while self . running : cv . imshow ( 'reference' , ref_frame ) try : ( corners , ids , rejected , recovered ) = retrieve ( False ) scaling = self . get_reference_scaling_naive ( corners , ids , self . _frame_width , self . _frame_height ) if len ( scaling ) == 2 : self . scaling_x = scaling [ 0 ] self . scaling_y = scaling [ 1 ] cv . destroyWindow ( 'reference' ) break except Empty : pass except Exception as e : print ( e ) break idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () while self . running : frame = np . copy ( initial_frame ) # First try to retrieve the list of tuples consisting of marker coordinates (position and angle) and IDs. # This can faile, because the retrieval of items from the queue can raise the Empty exception when there # currently is no item in the queue try : ( corners , ids , _ , _ ) = retrieve ( False ) markers = self . tracker . _transform_markers_to_center ( corners , ids ) self . _update_markers ( markers ) except Empty : pass except Exception as e : print ( e ) break super () . render ( frame , self . transform_matrix , self . _frame_width , self . _frame_width ) # frame = cv.warpPerspective(frame, self.transform_matrix, (self._frame_width, self._frame_width)) # print(frame.shape) cv . imshow ( self . window_name , frame ) idx = wait . multi_wait_or ( self . wait_delay , 'q' , 'f' ) if idx == - 1 : continue elif idx == 0 : break else : self . toggle_fullscreen () # Cleanup self . stop () return None","title":"start()"},{"location":"renderer/shared/","text":"Shared Source code in interface/renderer/shared.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class Shared : def __init__ ( self , cfg : Config , tracker : Tracker , window_name : str = 'rendering' ) -> None : self . wait_delay = fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . window_name = window_name self . raw_subscription_id = - 1 self . subscription_id = - 1 self . fullscreen = False self . tracker = tracker self . running = False self . cfg = cfg # Camera dimensions self . camera_frame_height = 0 self . camera_frame_width = 0 # Render layers self . render_layers : Dict [ int , RenderLayer ] = {} def is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . running : return True self . running = True return False def subscribe ( self , size : int = - 1 ) -> RetrieveFunc : ''' Subscribe to the tracker. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . subscription_id = id return retrieve def subscribe_raw ( self , size : int = - 1 ) -> RawRetrieveFunc : ''' Subscribe to the tracker in raw mode. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe_raw ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . raw_subscription_id = id return retrieve def draw_borders ( self , corners : tuple , frame : cv . Mat ): ''' Draw the border around a marker. Args: corners: List of corner positions. frame: Frame to render in. ''' cv . line ( frame , corners [ 0 ], corners [ 1 ], COLOR_GREEN , 2 ) # Top left to top right cv . line ( frame , corners [ 1 ], corners [ 2 ], COLOR_GREEN , 2 ) # Top right to bottom right cv . line ( frame , corners [ 2 ], corners [ 3 ], COLOR_GREEN , 2 ) # Bottom right to bottom left cv . line ( frame , corners [ 3 ], corners [ 0 ], COLOR_GREEN , 2 ) # Bottom left to top left def draw_angle ( self , corners : tuple , angle : float , frame : cv . Mat , with_text : bool = True ): ''' Draw a circle in the top-left corner and attach the angle as text to it. Args: corners: List of corner positions. angle: The angle in degrees. frame: Frame to render in. with_text: If the angle should be displayed as text. ''' cv . circle ( frame , corners [ 0 ], 4 , COLOR_RED , - 1 ) # Top left corner if with_text : cv . putText ( frame , ' {:.2f} ' . format ( angle ), corners [ 0 ], cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) def draw_center_point ( self , pos : tuple , id : int , frame : cv . Mat , with_text : bool = True ): ''' Draw a center point with the ID as text attached to it. Args: pos: Marker center position. id: Marker ID. frame: Frame to render in. with_text: If the marker ID should be displayed as text. ''' cv . circle ( frame , pos , 4 , COLOR_RED , - 1 ) if with_text : cv . putText ( frame , str ( id ), ( pos [ 0 ] - 10 , pos [ 1 ] - 45 ), cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) def toggle_fullscreen ( self ): ''' Toggle fullscreen of the rendering window. ''' if self . fullscreen : self . fullscreen = False cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_NORMAL ) else : self . fullscreen = True cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) def add_render_layer ( self , index : int , name : str , should_warp : bool = True ) -> Error : ''' Add a render layer. Args: index: Layer index. Higher indices render later. name: Name of the render layer. should_warp: If this layer should be warped by the projection transformation (Broken). Returns: An Error if an error was encountered, None if otherwise. ''' if index in self . render_layers . keys (): return Error ( f 'A render layer with index { index } ( { self . render_layers [ index ] . _name } ) already exists' ) self . render_layers [ index ] = RenderLayer ( index , name , should_warp ) return None def add_object_to_layer ( self , index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer. Args: index: Index of the render layer to add to. obj: Render object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not index in self . render_layers . keys (): return Error ( 'A layer at index {index} does not exist' ) self . render_layers [ index ] . add_object ( obj ) return None def add_object_to_layer_at_index ( self , layer_index : int , obj_index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer at a specific index. Args: layer_index: The layer index to add to. obj_index: Object index to add object at. obj: Object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . add_object_by_index ( obj_index , obj ) def get_object_on_layer_by_index ( self , layer_index : int , obj_index : int ) -> Result [ RenderObject , Error ]: ''' Get a render object on a layer by index. Args: layer_index: The layer index. obj_index: The object index. Returns: A result consisting of a RenderObject or an Error. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . get_object ( obj_index ) def render ( self , frame : cv . Mat , matrix : np . ndarray , width : int , height : int ): ''' Render the render layers one after each other. Args: frame: The frame to render in. matrix: Projection transformation matrix (Broken). width: Frame width. height: Frame height. ''' # First we render all layers which should be warped remanining : List [ RenderLayer ] = [] for layer in self . render_layers . values (): if not layer . _should_warp : remanining . append ( layer ) continue # print(f'Render {len(layer._objects)} objects on layer {layer._name}') layer . render ( frame ) # Warp if matrix . any (): # frame = cv.warpPerspective(frame, matrix, (width, height)) pass for layer in remanining : layer . render ( frame ) def stop ( self ): ''' Stop the render loop. ''' self . running = False cv . destroyAllWindows () self . tracker . unsubscribe ( self . subscription_id ) self . tracker . stop () add_object_to_layer ( index , obj ) Add a render object to a render layer. Parameters: Name Type Description Default index int Index of the render layer to add to. required obj RenderObject Render object to add. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def add_object_to_layer ( self , index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer. Args: index: Index of the render layer to add to. obj: Render object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not index in self . render_layers . keys (): return Error ( 'A layer at index {index} does not exist' ) self . render_layers [ index ] . add_object ( obj ) return None add_object_to_layer_at_index ( layer_index , obj_index , obj ) Add a render object to a render layer at a specific index. Parameters: Name Type Description Default layer_index int The layer index to add to. required obj_index int Object index to add object at. required obj RenderObject Object to add. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def add_object_to_layer_at_index ( self , layer_index : int , obj_index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer at a specific index. Args: layer_index: The layer index to add to. obj_index: Object index to add object at. obj: Object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . add_object_by_index ( obj_index , obj ) add_render_layer ( index , name , should_warp = True ) Add a render layer. Parameters: Name Type Description Default index int Layer index. Higher indices render later. required name str Name of the render layer. required should_warp bool If this layer should be warped by the projection transformation (Broken). True Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def add_render_layer ( self , index : int , name : str , should_warp : bool = True ) -> Error : ''' Add a render layer. Args: index: Layer index. Higher indices render later. name: Name of the render layer. should_warp: If this layer should be warped by the projection transformation (Broken). Returns: An Error if an error was encountered, None if otherwise. ''' if index in self . render_layers . keys (): return Error ( f 'A render layer with index { index } ( { self . render_layers [ index ] . _name } ) already exists' ) self . render_layers [ index ] = RenderLayer ( index , name , should_warp ) return None draw_angle ( corners , angle , frame , with_text = True ) Draw a circle in the top-left corner and attach the angle as text to it. Parameters: Name Type Description Default corners tuple List of corner positions. required angle float The angle in degrees. required frame cv . Mat Frame to render in. required with_text bool If the angle should be displayed as text. True Source code in interface/renderer/shared.py 93 94 95 96 97 98 99 100 101 102 103 104 105 def draw_angle ( self , corners : tuple , angle : float , frame : cv . Mat , with_text : bool = True ): ''' Draw a circle in the top-left corner and attach the angle as text to it. Args: corners: List of corner positions. angle: The angle in degrees. frame: Frame to render in. with_text: If the angle should be displayed as text. ''' cv . circle ( frame , corners [ 0 ], 4 , COLOR_RED , - 1 ) # Top left corner if with_text : cv . putText ( frame , ' {:.2f} ' . format ( angle ), corners [ 0 ], cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) draw_borders ( corners , frame ) Draw the border around a marker. Parameters: Name Type Description Default corners tuple List of corner positions. required frame cv . Mat Frame to render in. required Source code in interface/renderer/shared.py 80 81 82 83 84 85 86 87 88 89 90 91 def draw_borders ( self , corners : tuple , frame : cv . Mat ): ''' Draw the border around a marker. Args: corners: List of corner positions. frame: Frame to render in. ''' cv . line ( frame , corners [ 0 ], corners [ 1 ], COLOR_GREEN , 2 ) # Top left to top right cv . line ( frame , corners [ 1 ], corners [ 2 ], COLOR_GREEN , 2 ) # Top right to bottom right cv . line ( frame , corners [ 2 ], corners [ 3 ], COLOR_GREEN , 2 ) # Bottom right to bottom left cv . line ( frame , corners [ 3 ], corners [ 0 ], COLOR_GREEN , 2 ) # Bottom left to top left draw_center_point ( pos , id , frame , with_text = True ) Draw a center point with the ID as text attached to it. Parameters: Name Type Description Default pos tuple Marker center position. required id int Marker ID. required frame cv . Mat Frame to render in. required with_text bool If the marker ID should be displayed as text. True Source code in interface/renderer/shared.py 107 108 109 110 111 112 113 114 115 116 117 118 119 def draw_center_point ( self , pos : tuple , id : int , frame : cv . Mat , with_text : bool = True ): ''' Draw a center point with the ID as text attached to it. Args: pos: Marker center position. id: Marker ID. frame: Frame to render in. with_text: If the marker ID should be displayed as text. ''' cv . circle ( frame , pos , 4 , COLOR_RED , - 1 ) if with_text : cv . putText ( frame , str ( id ), ( pos [ 0 ] - 10 , pos [ 1 ] - 45 ), cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) get_object_on_layer_by_index ( layer_index , obj_index ) Get a render object on a layer by index. Parameters: Name Type Description Default layer_index int The layer index. required obj_index int The object index. required Returns: Type Description Result [ RenderObject , Error ] A result consisting of a RenderObject or an Error. Source code in interface/renderer/shared.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def get_object_on_layer_by_index ( self , layer_index : int , obj_index : int ) -> Result [ RenderObject , Error ]: ''' Get a render object on a layer by index. Args: layer_index: The layer index. obj_index: The object index. Returns: A result consisting of a RenderObject or an Error. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . get_object ( obj_index ) is_running () Returns if the renderer is already running. Returns: Type Description bool If renderer is running. Source code in interface/renderer/shared.py 33 34 35 36 37 38 39 40 41 42 43 44 def is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . running : return True self . running = True return False render ( frame , matrix , width , height ) Render the render layers one after each other. Parameters: Name Type Description Default frame cv . Mat The frame to render in. required matrix np . ndarray Projection transformation matrix (Broken). required width int Frame width. required height int Frame height. required Source code in interface/renderer/shared.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def render ( self , frame : cv . Mat , matrix : np . ndarray , width : int , height : int ): ''' Render the render layers one after each other. Args: frame: The frame to render in. matrix: Projection transformation matrix (Broken). width: Frame width. height: Frame height. ''' # First we render all layers which should be warped remanining : List [ RenderLayer ] = [] for layer in self . render_layers . values (): if not layer . _should_warp : remanining . append ( layer ) continue # print(f'Render {len(layer._objects)} objects on layer {layer._name}') layer . render ( frame ) # Warp if matrix . any (): # frame = cv.warpPerspective(frame, matrix, (width, height)) pass for layer in remanining : layer . render ( frame ) stop () Stop the render loop. Source code in interface/renderer/shared.py 226 227 228 229 230 231 232 233 234 def stop ( self ): ''' Stop the render loop. ''' self . running = False cv . destroyAllWindows () self . tracker . unsubscribe ( self . subscription_id ) self . tracker . stop () subscribe ( size =- 1 ) Subscribe to the tracker. Parameters: Name Type Description Default size int Size of the queue (Default: -1 => Unlimited). -1 Returns: Type Description RetrieveFunc A function to retrieve new marker positions. Source code in interface/renderer/shared.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def subscribe ( self , size : int = - 1 ) -> RetrieveFunc : ''' Subscribe to the tracker. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . subscription_id = id return retrieve subscribe_raw ( size =- 1 ) Subscribe to the tracker in raw mode. Parameters: Name Type Description Default size int Size of the queue (Default: -1 => Unlimited). -1 Returns: Type Description RawRetrieveFunc A function to retrieve new marker positions. Source code in interface/renderer/shared.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def subscribe_raw ( self , size : int = - 1 ) -> RawRetrieveFunc : ''' Subscribe to the tracker in raw mode. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe_raw ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . raw_subscription_id = id return retrieve toggle_fullscreen () Toggle fullscreen of the rendering window. Source code in interface/renderer/shared.py 121 122 123 124 125 126 127 128 129 130 def toggle_fullscreen ( self ): ''' Toggle fullscreen of the rendering window. ''' if self . fullscreen : self . fullscreen = False cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_NORMAL ) else : self . fullscreen = True cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN )","title":"Shared"},{"location":"renderer/shared/#interface.renderer.shared.Shared","text":"Source code in interface/renderer/shared.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class Shared : def __init__ ( self , cfg : Config , tracker : Tracker , window_name : str = 'rendering' ) -> None : self . wait_delay = fps_to_ms ( cfg [ 'capture' ][ 'fps' ]) self . window_name = window_name self . raw_subscription_id = - 1 self . subscription_id = - 1 self . fullscreen = False self . tracker = tracker self . running = False self . cfg = cfg # Camera dimensions self . camera_frame_height = 0 self . camera_frame_width = 0 # Render layers self . render_layers : Dict [ int , RenderLayer ] = {} def is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . running : return True self . running = True return False def subscribe ( self , size : int = - 1 ) -> RetrieveFunc : ''' Subscribe to the tracker. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . subscription_id = id return retrieve def subscribe_raw ( self , size : int = - 1 ) -> RawRetrieveFunc : ''' Subscribe to the tracker in raw mode. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe_raw ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . raw_subscription_id = id return retrieve def draw_borders ( self , corners : tuple , frame : cv . Mat ): ''' Draw the border around a marker. Args: corners: List of corner positions. frame: Frame to render in. ''' cv . line ( frame , corners [ 0 ], corners [ 1 ], COLOR_GREEN , 2 ) # Top left to top right cv . line ( frame , corners [ 1 ], corners [ 2 ], COLOR_GREEN , 2 ) # Top right to bottom right cv . line ( frame , corners [ 2 ], corners [ 3 ], COLOR_GREEN , 2 ) # Bottom right to bottom left cv . line ( frame , corners [ 3 ], corners [ 0 ], COLOR_GREEN , 2 ) # Bottom left to top left def draw_angle ( self , corners : tuple , angle : float , frame : cv . Mat , with_text : bool = True ): ''' Draw a circle in the top-left corner and attach the angle as text to it. Args: corners: List of corner positions. angle: The angle in degrees. frame: Frame to render in. with_text: If the angle should be displayed as text. ''' cv . circle ( frame , corners [ 0 ], 4 , COLOR_RED , - 1 ) # Top left corner if with_text : cv . putText ( frame , ' {:.2f} ' . format ( angle ), corners [ 0 ], cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) def draw_center_point ( self , pos : tuple , id : int , frame : cv . Mat , with_text : bool = True ): ''' Draw a center point with the ID as text attached to it. Args: pos: Marker center position. id: Marker ID. frame: Frame to render in. with_text: If the marker ID should be displayed as text. ''' cv . circle ( frame , pos , 4 , COLOR_RED , - 1 ) if with_text : cv . putText ( frame , str ( id ), ( pos [ 0 ] - 10 , pos [ 1 ] - 45 ), cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 ) def toggle_fullscreen ( self ): ''' Toggle fullscreen of the rendering window. ''' if self . fullscreen : self . fullscreen = False cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_NORMAL ) else : self . fullscreen = True cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN ) def add_render_layer ( self , index : int , name : str , should_warp : bool = True ) -> Error : ''' Add a render layer. Args: index: Layer index. Higher indices render later. name: Name of the render layer. should_warp: If this layer should be warped by the projection transformation (Broken). Returns: An Error if an error was encountered, None if otherwise. ''' if index in self . render_layers . keys (): return Error ( f 'A render layer with index { index } ( { self . render_layers [ index ] . _name } ) already exists' ) self . render_layers [ index ] = RenderLayer ( index , name , should_warp ) return None def add_object_to_layer ( self , index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer. Args: index: Index of the render layer to add to. obj: Render object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not index in self . render_layers . keys (): return Error ( 'A layer at index {index} does not exist' ) self . render_layers [ index ] . add_object ( obj ) return None def add_object_to_layer_at_index ( self , layer_index : int , obj_index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer at a specific index. Args: layer_index: The layer index to add to. obj_index: Object index to add object at. obj: Object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . add_object_by_index ( obj_index , obj ) def get_object_on_layer_by_index ( self , layer_index : int , obj_index : int ) -> Result [ RenderObject , Error ]: ''' Get a render object on a layer by index. Args: layer_index: The layer index. obj_index: The object index. Returns: A result consisting of a RenderObject or an Error. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . get_object ( obj_index ) def render ( self , frame : cv . Mat , matrix : np . ndarray , width : int , height : int ): ''' Render the render layers one after each other. Args: frame: The frame to render in. matrix: Projection transformation matrix (Broken). width: Frame width. height: Frame height. ''' # First we render all layers which should be warped remanining : List [ RenderLayer ] = [] for layer in self . render_layers . values (): if not layer . _should_warp : remanining . append ( layer ) continue # print(f'Render {len(layer._objects)} objects on layer {layer._name}') layer . render ( frame ) # Warp if matrix . any (): # frame = cv.warpPerspective(frame, matrix, (width, height)) pass for layer in remanining : layer . render ( frame ) def stop ( self ): ''' Stop the render loop. ''' self . running = False cv . destroyAllWindows () self . tracker . unsubscribe ( self . subscription_id ) self . tracker . stop ()","title":"Shared"},{"location":"renderer/shared/#interface.renderer.shared.Shared.add_object_to_layer","text":"Add a render object to a render layer. Parameters: Name Type Description Default index int Index of the render layer to add to. required obj RenderObject Render object to add. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def add_object_to_layer ( self , index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer. Args: index: Index of the render layer to add to. obj: Render object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not index in self . render_layers . keys (): return Error ( 'A layer at index {index} does not exist' ) self . render_layers [ index ] . add_object ( obj ) return None","title":"add_object_to_layer()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.add_object_to_layer_at_index","text":"Add a render object to a render layer at a specific index. Parameters: Name Type Description Default layer_index int The layer index to add to. required obj_index int Object index to add object at. required obj RenderObject Object to add. required Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def add_object_to_layer_at_index ( self , layer_index : int , obj_index : int , obj : RenderObject ) -> Error : ''' Add a render object to a render layer at a specific index. Args: layer_index: The layer index to add to. obj_index: Object index to add object at. obj: Object to add. Returns: An Error if an error was encountered, None if otherwise. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . add_object_by_index ( obj_index , obj )","title":"add_object_to_layer_at_index()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.add_render_layer","text":"Add a render layer. Parameters: Name Type Description Default index int Layer index. Higher indices render later. required name str Name of the render layer. required should_warp bool If this layer should be warped by the projection transformation (Broken). True Returns: Type Description Error An Error if an error was encountered, None if otherwise. Source code in interface/renderer/shared.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def add_render_layer ( self , index : int , name : str , should_warp : bool = True ) -> Error : ''' Add a render layer. Args: index: Layer index. Higher indices render later. name: Name of the render layer. should_warp: If this layer should be warped by the projection transformation (Broken). Returns: An Error if an error was encountered, None if otherwise. ''' if index in self . render_layers . keys (): return Error ( f 'A render layer with index { index } ( { self . render_layers [ index ] . _name } ) already exists' ) self . render_layers [ index ] = RenderLayer ( index , name , should_warp ) return None","title":"add_render_layer()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.draw_angle","text":"Draw a circle in the top-left corner and attach the angle as text to it. Parameters: Name Type Description Default corners tuple List of corner positions. required angle float The angle in degrees. required frame cv . Mat Frame to render in. required with_text bool If the angle should be displayed as text. True Source code in interface/renderer/shared.py 93 94 95 96 97 98 99 100 101 102 103 104 105 def draw_angle ( self , corners : tuple , angle : float , frame : cv . Mat , with_text : bool = True ): ''' Draw a circle in the top-left corner and attach the angle as text to it. Args: corners: List of corner positions. angle: The angle in degrees. frame: Frame to render in. with_text: If the angle should be displayed as text. ''' cv . circle ( frame , corners [ 0 ], 4 , COLOR_RED , - 1 ) # Top left corner if with_text : cv . putText ( frame , ' {:.2f} ' . format ( angle ), corners [ 0 ], cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 )","title":"draw_angle()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.draw_borders","text":"Draw the border around a marker. Parameters: Name Type Description Default corners tuple List of corner positions. required frame cv . Mat Frame to render in. required Source code in interface/renderer/shared.py 80 81 82 83 84 85 86 87 88 89 90 91 def draw_borders ( self , corners : tuple , frame : cv . Mat ): ''' Draw the border around a marker. Args: corners: List of corner positions. frame: Frame to render in. ''' cv . line ( frame , corners [ 0 ], corners [ 1 ], COLOR_GREEN , 2 ) # Top left to top right cv . line ( frame , corners [ 1 ], corners [ 2 ], COLOR_GREEN , 2 ) # Top right to bottom right cv . line ( frame , corners [ 2 ], corners [ 3 ], COLOR_GREEN , 2 ) # Bottom right to bottom left cv . line ( frame , corners [ 3 ], corners [ 0 ], COLOR_GREEN , 2 ) # Bottom left to top left","title":"draw_borders()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.draw_center_point","text":"Draw a center point with the ID as text attached to it. Parameters: Name Type Description Default pos tuple Marker center position. required id int Marker ID. required frame cv . Mat Frame to render in. required with_text bool If the marker ID should be displayed as text. True Source code in interface/renderer/shared.py 107 108 109 110 111 112 113 114 115 116 117 118 119 def draw_center_point ( self , pos : tuple , id : int , frame : cv . Mat , with_text : bool = True ): ''' Draw a center point with the ID as text attached to it. Args: pos: Marker center position. id: Marker ID. frame: Frame to render in. with_text: If the marker ID should be displayed as text. ''' cv . circle ( frame , pos , 4 , COLOR_RED , - 1 ) if with_text : cv . putText ( frame , str ( id ), ( pos [ 0 ] - 10 , pos [ 1 ] - 45 ), cv . FONT_HERSHEY_SIMPLEX , 0.8 , COLOR_RED , 2 )","title":"draw_center_point()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.get_object_on_layer_by_index","text":"Get a render object on a layer by index. Parameters: Name Type Description Default layer_index int The layer index. required obj_index int The object index. required Returns: Type Description Result [ RenderObject , Error ] A result consisting of a RenderObject or an Error. Source code in interface/renderer/shared.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def get_object_on_layer_by_index ( self , layer_index : int , obj_index : int ) -> Result [ RenderObject , Error ]: ''' Get a render object on a layer by index. Args: layer_index: The layer index. obj_index: The object index. Returns: A result consisting of a RenderObject or an Error. ''' if not layer_index in self . render_layers . keys (): return Error ( f 'A layer at index { layer_index } does not exist' ) return self . render_layers [ layer_index ] . get_object ( obj_index )","title":"get_object_on_layer_by_index()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.is_running","text":"Returns if the renderer is already running. Returns: Type Description bool If renderer is running. Source code in interface/renderer/shared.py 33 34 35 36 37 38 39 40 41 42 43 44 def is_running ( self ) -> bool : ''' Returns if the renderer is already running. Returns: If renderer is running. ''' if self . running : return True self . running = True return False","title":"is_running()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.render","text":"Render the render layers one after each other. Parameters: Name Type Description Default frame cv . Mat The frame to render in. required matrix np . ndarray Projection transformation matrix (Broken). required width int Frame width. required height int Frame height. required Source code in interface/renderer/shared.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def render ( self , frame : cv . Mat , matrix : np . ndarray , width : int , height : int ): ''' Render the render layers one after each other. Args: frame: The frame to render in. matrix: Projection transformation matrix (Broken). width: Frame width. height: Frame height. ''' # First we render all layers which should be warped remanining : List [ RenderLayer ] = [] for layer in self . render_layers . values (): if not layer . _should_warp : remanining . append ( layer ) continue # print(f'Render {len(layer._objects)} objects on layer {layer._name}') layer . render ( frame ) # Warp if matrix . any (): # frame = cv.warpPerspective(frame, matrix, (width, height)) pass for layer in remanining : layer . render ( frame )","title":"render()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.stop","text":"Stop the render loop. Source code in interface/renderer/shared.py 226 227 228 229 230 231 232 233 234 def stop ( self ): ''' Stop the render loop. ''' self . running = False cv . destroyAllWindows () self . tracker . unsubscribe ( self . subscription_id ) self . tracker . stop ()","title":"stop()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.subscribe","text":"Subscribe to the tracker. Parameters: Name Type Description Default size int Size of the queue (Default: -1 => Unlimited). -1 Returns: Type Description RetrieveFunc A function to retrieve new marker positions. Source code in interface/renderer/shared.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def subscribe ( self , size : int = - 1 ) -> RetrieveFunc : ''' Subscribe to the tracker. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . subscription_id = id return retrieve","title":"subscribe()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.subscribe_raw","text":"Subscribe to the tracker in raw mode. Parameters: Name Type Description Default size int Size of the queue (Default: -1 => Unlimited). -1 Returns: Type Description RawRetrieveFunc A function to retrieve new marker positions. Source code in interface/renderer/shared.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def subscribe_raw ( self , size : int = - 1 ) -> RawRetrieveFunc : ''' Subscribe to the tracker in raw mode. Args: size: Size of the queue (Default: -1 => Unlimited). Returns: A function to retrieve new marker positions. ''' id , params , retrieve = self . tracker . subscribe_raw ( size ) self . camera_frame_height = params [ 1 ] self . camera_frame_width = params [ 0 ] self . raw_subscription_id = id return retrieve","title":"subscribe_raw()"},{"location":"renderer/shared/#interface.renderer.shared.Shared.toggle_fullscreen","text":"Toggle fullscreen of the rendering window. Source code in interface/renderer/shared.py 121 122 123 124 125 126 127 128 129 130 def toggle_fullscreen ( self ): ''' Toggle fullscreen of the rendering window. ''' if self . fullscreen : self . fullscreen = False cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_NORMAL ) else : self . fullscreen = True cv . setWindowProperty ( self . window_name , cv . WND_PROP_FULLSCREEN , cv . WINDOW_FULLSCREEN )","title":"toggle_fullscreen()"},{"location":"renderer/transformer/","text":"Transformer Bases: Shared Source code in interface/renderer/transformer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 class Transformer ( Shared ): def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData , tracker : Tracker ) -> None : super () . __init__ ( cfg , tracker ) typ = type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) self . dict = cv . aruco . Dictionary_get ( t ) self . board = board_from ( 3 , 3 , self . dict , marker_length = 0.09 , marker_separation = 0.01 ) self . corner_transform = np . zeros (( 4 , 2 ), dtype = \"float32\" ) self . transform_matrix = np . zeros ([]) self . calib_data = calib_data self . transform_height = 0 self . transform_width = 0 self . scaling_x = 1 self . scaling_y = 1 self . axis = np . float32 ([ [ - .5 , - .5 , 0 ], [ - .5 , .5 , 0 ], [ .5 , .5 , 0 ], [ .5 , - .5 , 0 ], [ - .5 , - .5 , 1 ], [ - .5 , .5 , 1 ], [ .5 , .5 , 1 ], [ .5 , - .5 , 1 ] ]) def get_reference_scaling_naive ( self , corners : CornerList , ids : IDList , width : int , height : int ) -> Tuple [ float , float ]: '''''' if len ( corners ) < 4 : return () pairs = [] for c in zip ( corners , ids ): if c [ 1 ][ 0 ] in [ 0 , 1 , 2 , 3 ]: pairs . append (( c [ 0 ][ 0 ], c [ 1 ][ 0 ])) pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # Calc width scaling top_width = pairs [ 1 ][ 0 ][ 0 ][ 0 ] - pairs [ 0 ][ 0 ][ 0 ][ 0 ] bot_width = pairs [ 2 ][ 0 ][ 0 ][ 0 ] - pairs [ 3 ][ 0 ][ 0 ][ 0 ] avg_width = ( top_width + bot_width ) / 2 # Calc heigth scaling left_height = pairs [ 3 ][ 0 ][ 0 ][ 1 ] - pairs [ 0 ][ 0 ][ 0 ][ 1 ] right_height = pairs [ 2 ][ 0 ][ 0 ][ 1 ] - pairs [ 1 ][ 0 ][ 0 ][ 1 ] avg_height = ( left_height + right_height ) / 2 return ( width / avg_width , height / avg_height ) def get_reference_corners ( self , corners : CornerList , ids : IDList ): ''' This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. ''' if len ( corners ) < 4 : return np . array ([]) rect_corner_corners = [] rect_corner_ids = [] for c in zip ( corners , ids ): if c [ 1 ] in [ 0 , 1 , 2 , 3 ]: rect_corner_corners . append ( c [ 0 ]) rect_corner_ids . append ( c [ 1 ]) if len ( rect_corner_corners ) != 4 : return np . array ([]) ok , frame = self . tracker . get_frame () if not ok : return np . array ([]) ret , proj_corners , proj_ids = cv . aruco . interpolateCornersCharuco ( rect_corner_corners , np . array ( rect_corner_ids ), frame , self . board ) if ret != 4 : return np . array ([]) return proj_corners def transform_in_intervals ( self ): ''' Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. ''' t = threading . Thread ( None , self . calc_corner_transform , 'transform-projection' ) self . transform_thread = t t . start () def calc_corner_transform ( self ): ''' Retrieve the raw tracking data to calculate the transformation matrix. ''' retrieve = self . subscribe_raw ( 1 ) while self . running : all_img_pts = [] try : ( corners , ids , rejected , recovered ) = retrieve ( False ) if len ( ids ) == 0 : continue rvecs , tvecs , obj_points = cv . aruco . estimatePoseSingleMarkers ( corners , 1 , self . calib_data [ 0 ], self . calib_data [ 1 ] ) for rvec , tvec in zip ( rvecs , tvecs ): try : img_pts , jacobian = cv . projectPoints ( self . axis , rvec , tvec , self . calib_data [ 0 ], self . calib_data [ 1 ] ) all_img_pts . append ( img_pts ) except : continue if [ 0 ] in ids and [ 1 ] in ids and [ 2 ] in ids and [ 3 ] in ids : self . corner_transform [ 0 ] = all_img_pts [ np . where ( ids == [ 0 ])[ 0 ][ 0 ]][ 1 ][ 0 ] self . corner_transform [ 1 ] = all_img_pts [ np . where ( ids == [ 1 ])[ 0 ][ 0 ]][ 2 ][ 0 ] self . corner_transform [ 2 ] = all_img_pts [ np . where ( ids == [ 2 ])[ 0 ][ 0 ]][ 3 ][ 0 ] self . corner_transform [ 3 ] = all_img_pts [ np . where ( ids == [ 3 ])[ 0 ][ 0 ]][ 0 ][ 0 ] self . calc_projection_transform () print ( 'Done transform' ) break except : continue self . tracker . unsubscribe ( self . raw_subscription_id ) def calc_projection_transform ( self ): '''''' ( tl , tr , br , bl ) = self . corner_transform # Calculate the adjusted width. For this we take the max distance of the top-left and top-right corners and the # maximum distance of the bottom-left and bottom-right corners. Then take the maximum of both these values. width_top = np . sqrt ((( tr [ 0 ] - tl [ 0 ]) ** 2 ) + (( tr [ 1 ] - tl [ 1 ]) ** 2 )) width_bot = np . sqrt ((( br [ 0 ] - bl [ 0 ]) ** 2 ) + (( br [ 1 ] - bl [ 1 ]) ** 2 )) width = max ( int ( width_top ), int ( width_bot )) # Calculate the height the same way we calculated the width. This time we uss the top-left + bottom-left and # top-right + bottom-right distances. Take the maximum of both these values again. height_left = np . sqrt ((( tl [ 0 ] - bl [ 0 ]) ** 2 ) + (( tl [ 1 ] - bl [ 1 ]) ** 2 )) height_right = np . sqrt ((( tr [ 0 ] - br [ 0 ]) ** 2 ) + (( tr [ 1 ] - br [ 1 ]) ** 2 )) height = max ( int ( height_left ), int ( height_right )) dst = np . array ([ [ 0 , 0 ], [ width - 1 , 0 ], [ width - 1 , height - 1 ], [ 0 , height - 1 ] ], dtype = \"float32\" ) self . transform_matrix = cv . getPerspectiveTransform ( self . corner_transform , dst ) self . transform_height = height self . transform_width = width calc_corner_transform () Retrieve the raw tracking data to calculate the transformation matrix. Source code in interface/renderer/transformer.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def calc_corner_transform ( self ): ''' Retrieve the raw tracking data to calculate the transformation matrix. ''' retrieve = self . subscribe_raw ( 1 ) while self . running : all_img_pts = [] try : ( corners , ids , rejected , recovered ) = retrieve ( False ) if len ( ids ) == 0 : continue rvecs , tvecs , obj_points = cv . aruco . estimatePoseSingleMarkers ( corners , 1 , self . calib_data [ 0 ], self . calib_data [ 1 ] ) for rvec , tvec in zip ( rvecs , tvecs ): try : img_pts , jacobian = cv . projectPoints ( self . axis , rvec , tvec , self . calib_data [ 0 ], self . calib_data [ 1 ] ) all_img_pts . append ( img_pts ) except : continue if [ 0 ] in ids and [ 1 ] in ids and [ 2 ] in ids and [ 3 ] in ids : self . corner_transform [ 0 ] = all_img_pts [ np . where ( ids == [ 0 ])[ 0 ][ 0 ]][ 1 ][ 0 ] self . corner_transform [ 1 ] = all_img_pts [ np . where ( ids == [ 1 ])[ 0 ][ 0 ]][ 2 ][ 0 ] self . corner_transform [ 2 ] = all_img_pts [ np . where ( ids == [ 2 ])[ 0 ][ 0 ]][ 3 ][ 0 ] self . corner_transform [ 3 ] = all_img_pts [ np . where ( ids == [ 3 ])[ 0 ][ 0 ]][ 0 ][ 0 ] self . calc_projection_transform () print ( 'Done transform' ) break except : continue self . tracker . unsubscribe ( self . raw_subscription_id ) get_reference_corners ( corners , ids ) This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. Source code in interface/renderer/transformer.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_reference_corners ( self , corners : CornerList , ids : IDList ): ''' This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. ''' if len ( corners ) < 4 : return np . array ([]) rect_corner_corners = [] rect_corner_ids = [] for c in zip ( corners , ids ): if c [ 1 ] in [ 0 , 1 , 2 , 3 ]: rect_corner_corners . append ( c [ 0 ]) rect_corner_ids . append ( c [ 1 ]) if len ( rect_corner_corners ) != 4 : return np . array ([]) ok , frame = self . tracker . get_frame () if not ok : return np . array ([]) ret , proj_corners , proj_ids = cv . aruco . interpolateCornersCharuco ( rect_corner_corners , np . array ( rect_corner_ids ), frame , self . board ) if ret != 4 : return np . array ([]) return proj_corners transform_in_intervals () Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. Source code in interface/renderer/transformer.py 109 110 111 112 113 114 115 116 117 def transform_in_intervals ( self ): ''' Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. ''' t = threading . Thread ( None , self . calc_corner_transform , 'transform-projection' ) self . transform_thread = t t . start ()","title":"Transformer"},{"location":"renderer/transformer/#interface.renderer.transformer.Transformer","text":"Bases: Shared Source code in interface/renderer/transformer.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 class Transformer ( Shared ): def __init__ ( self , cfg : Config , calib_data : CharucoCalibrationData , tracker : Tracker ) -> None : super () . __init__ ( cfg , tracker ) typ = type_from ( cfg [ 'capture' ][ 'aruco' ][ 'size' ], cfg [ 'capture' ][ 'aruco' ][ 'uniques' ] ) t , ok = dict_from ( typ ) if not ok : raise Exception ( 'Failed to instantiate Tracker object' ) self . dict = cv . aruco . Dictionary_get ( t ) self . board = board_from ( 3 , 3 , self . dict , marker_length = 0.09 , marker_separation = 0.01 ) self . corner_transform = np . zeros (( 4 , 2 ), dtype = \"float32\" ) self . transform_matrix = np . zeros ([]) self . calib_data = calib_data self . transform_height = 0 self . transform_width = 0 self . scaling_x = 1 self . scaling_y = 1 self . axis = np . float32 ([ [ - .5 , - .5 , 0 ], [ - .5 , .5 , 0 ], [ .5 , .5 , 0 ], [ .5 , - .5 , 0 ], [ - .5 , - .5 , 1 ], [ - .5 , .5 , 1 ], [ .5 , .5 , 1 ], [ .5 , - .5 , 1 ] ]) def get_reference_scaling_naive ( self , corners : CornerList , ids : IDList , width : int , height : int ) -> Tuple [ float , float ]: '''''' if len ( corners ) < 4 : return () pairs = [] for c in zip ( corners , ids ): if c [ 1 ][ 0 ] in [ 0 , 1 , 2 , 3 ]: pairs . append (( c [ 0 ][ 0 ], c [ 1 ][ 0 ])) pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # Calc width scaling top_width = pairs [ 1 ][ 0 ][ 0 ][ 0 ] - pairs [ 0 ][ 0 ][ 0 ][ 0 ] bot_width = pairs [ 2 ][ 0 ][ 0 ][ 0 ] - pairs [ 3 ][ 0 ][ 0 ][ 0 ] avg_width = ( top_width + bot_width ) / 2 # Calc heigth scaling left_height = pairs [ 3 ][ 0 ][ 0 ][ 1 ] - pairs [ 0 ][ 0 ][ 0 ][ 1 ] right_height = pairs [ 2 ][ 0 ][ 0 ][ 1 ] - pairs [ 1 ][ 0 ][ 0 ][ 1 ] avg_height = ( left_height + right_height ) / 2 return ( width / avg_width , height / avg_height ) def get_reference_corners ( self , corners : CornerList , ids : IDList ): ''' This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. ''' if len ( corners ) < 4 : return np . array ([]) rect_corner_corners = [] rect_corner_ids = [] for c in zip ( corners , ids ): if c [ 1 ] in [ 0 , 1 , 2 , 3 ]: rect_corner_corners . append ( c [ 0 ]) rect_corner_ids . append ( c [ 1 ]) if len ( rect_corner_corners ) != 4 : return np . array ([]) ok , frame = self . tracker . get_frame () if not ok : return np . array ([]) ret , proj_corners , proj_ids = cv . aruco . interpolateCornersCharuco ( rect_corner_corners , np . array ( rect_corner_ids ), frame , self . board ) if ret != 4 : return np . array ([]) return proj_corners def transform_in_intervals ( self ): ''' Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. ''' t = threading . Thread ( None , self . calc_corner_transform , 'transform-projection' ) self . transform_thread = t t . start () def calc_corner_transform ( self ): ''' Retrieve the raw tracking data to calculate the transformation matrix. ''' retrieve = self . subscribe_raw ( 1 ) while self . running : all_img_pts = [] try : ( corners , ids , rejected , recovered ) = retrieve ( False ) if len ( ids ) == 0 : continue rvecs , tvecs , obj_points = cv . aruco . estimatePoseSingleMarkers ( corners , 1 , self . calib_data [ 0 ], self . calib_data [ 1 ] ) for rvec , tvec in zip ( rvecs , tvecs ): try : img_pts , jacobian = cv . projectPoints ( self . axis , rvec , tvec , self . calib_data [ 0 ], self . calib_data [ 1 ] ) all_img_pts . append ( img_pts ) except : continue if [ 0 ] in ids and [ 1 ] in ids and [ 2 ] in ids and [ 3 ] in ids : self . corner_transform [ 0 ] = all_img_pts [ np . where ( ids == [ 0 ])[ 0 ][ 0 ]][ 1 ][ 0 ] self . corner_transform [ 1 ] = all_img_pts [ np . where ( ids == [ 1 ])[ 0 ][ 0 ]][ 2 ][ 0 ] self . corner_transform [ 2 ] = all_img_pts [ np . where ( ids == [ 2 ])[ 0 ][ 0 ]][ 3 ][ 0 ] self . corner_transform [ 3 ] = all_img_pts [ np . where ( ids == [ 3 ])[ 0 ][ 0 ]][ 0 ][ 0 ] self . calc_projection_transform () print ( 'Done transform' ) break except : continue self . tracker . unsubscribe ( self . raw_subscription_id ) def calc_projection_transform ( self ): '''''' ( tl , tr , br , bl ) = self . corner_transform # Calculate the adjusted width. For this we take the max distance of the top-left and top-right corners and the # maximum distance of the bottom-left and bottom-right corners. Then take the maximum of both these values. width_top = np . sqrt ((( tr [ 0 ] - tl [ 0 ]) ** 2 ) + (( tr [ 1 ] - tl [ 1 ]) ** 2 )) width_bot = np . sqrt ((( br [ 0 ] - bl [ 0 ]) ** 2 ) + (( br [ 1 ] - bl [ 1 ]) ** 2 )) width = max ( int ( width_top ), int ( width_bot )) # Calculate the height the same way we calculated the width. This time we uss the top-left + bottom-left and # top-right + bottom-right distances. Take the maximum of both these values again. height_left = np . sqrt ((( tl [ 0 ] - bl [ 0 ]) ** 2 ) + (( tl [ 1 ] - bl [ 1 ]) ** 2 )) height_right = np . sqrt ((( tr [ 0 ] - br [ 0 ]) ** 2 ) + (( tr [ 1 ] - br [ 1 ]) ** 2 )) height = max ( int ( height_left ), int ( height_right )) dst = np . array ([ [ 0 , 0 ], [ width - 1 , 0 ], [ width - 1 , height - 1 ], [ 0 , height - 1 ] ], dtype = \"float32\" ) self . transform_matrix = cv . getPerspectiveTransform ( self . corner_transform , dst ) self . transform_height = height self . transform_width = width","title":"Transformer"},{"location":"renderer/transformer/#interface.renderer.transformer.Transformer.calc_corner_transform","text":"Retrieve the raw tracking data to calculate the transformation matrix. Source code in interface/renderer/transformer.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def calc_corner_transform ( self ): ''' Retrieve the raw tracking data to calculate the transformation matrix. ''' retrieve = self . subscribe_raw ( 1 ) while self . running : all_img_pts = [] try : ( corners , ids , rejected , recovered ) = retrieve ( False ) if len ( ids ) == 0 : continue rvecs , tvecs , obj_points = cv . aruco . estimatePoseSingleMarkers ( corners , 1 , self . calib_data [ 0 ], self . calib_data [ 1 ] ) for rvec , tvec in zip ( rvecs , tvecs ): try : img_pts , jacobian = cv . projectPoints ( self . axis , rvec , tvec , self . calib_data [ 0 ], self . calib_data [ 1 ] ) all_img_pts . append ( img_pts ) except : continue if [ 0 ] in ids and [ 1 ] in ids and [ 2 ] in ids and [ 3 ] in ids : self . corner_transform [ 0 ] = all_img_pts [ np . where ( ids == [ 0 ])[ 0 ][ 0 ]][ 1 ][ 0 ] self . corner_transform [ 1 ] = all_img_pts [ np . where ( ids == [ 1 ])[ 0 ][ 0 ]][ 2 ][ 0 ] self . corner_transform [ 2 ] = all_img_pts [ np . where ( ids == [ 2 ])[ 0 ][ 0 ]][ 3 ][ 0 ] self . corner_transform [ 3 ] = all_img_pts [ np . where ( ids == [ 3 ])[ 0 ][ 0 ]][ 0 ][ 0 ] self . calc_projection_transform () print ( 'Done transform' ) break except : continue self . tracker . unsubscribe ( self . raw_subscription_id )","title":"calc_corner_transform()"},{"location":"renderer/transformer/#interface.renderer.transformer.Transformer.get_reference_corners","text":"This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. Source code in interface/renderer/transformer.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_reference_corners ( self , corners : CornerList , ids : IDList ): ''' This function receives a variable number of marker corner coordinates. If there are at least 4 markers, this tries to find the rectangle framed by four corner morkers. ''' if len ( corners ) < 4 : return np . array ([]) rect_corner_corners = [] rect_corner_ids = [] for c in zip ( corners , ids ): if c [ 1 ] in [ 0 , 1 , 2 , 3 ]: rect_corner_corners . append ( c [ 0 ]) rect_corner_ids . append ( c [ 1 ]) if len ( rect_corner_corners ) != 4 : return np . array ([]) ok , frame = self . tracker . get_frame () if not ok : return np . array ([]) ret , proj_corners , proj_ids = cv . aruco . interpolateCornersCharuco ( rect_corner_corners , np . array ( rect_corner_ids ), frame , self . board ) if ret != 4 : return np . array ([]) return proj_corners","title":"get_reference_corners()"},{"location":"renderer/transformer/#interface.renderer.transformer.Transformer.transform_in_intervals","text":"Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. Source code in interface/renderer/transformer.py 109 110 111 112 113 114 115 116 117 def transform_in_intervals ( self ): ''' Transform the projection in regular intervals in a separate thread. The transformation is needed to adjust the rendering based on the detected outer edge of the corner ArUco markers. To reduce the computing needed we don't calculate the transformation every frame, but every n seconds. ''' t = threading . Thread ( None , self . calc_corner_transform , 'transform-projection' ) self . transform_thread = t t . start ()","title":"transform_in_intervals()"},{"location":"typings/client/","text":"RequestResult Source code in interface/typings/client.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class RequestResult : _is_error : bool _message : str _status : int _data : dict def __init__ ( self , data : dict , status : int , message : str , is_error : bool = False ) -> None : self . _is_error = is_error self . _message = message self . _status = status self . _data = data def is_error ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _is_error def data ( self ) -> dict : ''' Returns the response data. 'None' if error. ''' return self . _data def status ( self ) -> int : ''' Returns the HTTP status code of the response. Returns '-1' if no request was made. ''' return self . _status def msg ( self ) -> str : ''' Returns a result message with further details about the error or successful response. ''' return self . _message data () Returns the response data. 'None' if error. Source code in interface/typings/client.py 26 27 28 29 30 def data ( self ) -> dict : ''' Returns the response data. 'None' if error. ''' return self . _data is_error () Returns if the result is an error. Source code in interface/typings/client.py 20 21 22 23 24 def is_error ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _is_error msg () Returns a result message with further details about the error or successful response. Source code in interface/typings/client.py 38 39 40 41 42 def msg ( self ) -> str : ''' Returns a result message with further details about the error or successful response. ''' return self . _message status () Returns the HTTP status code of the response. Returns '-1' if no request was made. Source code in interface/typings/client.py 32 33 34 35 36 def status ( self ) -> int : ''' Returns the HTTP status code of the response. Returns '-1' if no request was made. ''' return self . _status","title":"Client"},{"location":"typings/client/#interface.typings.client.RequestResult","text":"Source code in interface/typings/client.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class RequestResult : _is_error : bool _message : str _status : int _data : dict def __init__ ( self , data : dict , status : int , message : str , is_error : bool = False ) -> None : self . _is_error = is_error self . _message = message self . _status = status self . _data = data def is_error ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _is_error def data ( self ) -> dict : ''' Returns the response data. 'None' if error. ''' return self . _data def status ( self ) -> int : ''' Returns the HTTP status code of the response. Returns '-1' if no request was made. ''' return self . _status def msg ( self ) -> str : ''' Returns a result message with further details about the error or successful response. ''' return self . _message","title":"RequestResult"},{"location":"typings/client/#interface.typings.client.RequestResult.data","text":"Returns the response data. 'None' if error. Source code in interface/typings/client.py 26 27 28 29 30 def data ( self ) -> dict : ''' Returns the response data. 'None' if error. ''' return self . _data","title":"data()"},{"location":"typings/client/#interface.typings.client.RequestResult.is_error","text":"Returns if the result is an error. Source code in interface/typings/client.py 20 21 22 23 24 def is_error ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _is_error","title":"is_error()"},{"location":"typings/client/#interface.typings.client.RequestResult.msg","text":"Returns a result message with further details about the error or successful response. Source code in interface/typings/client.py 38 39 40 41 42 def msg ( self ) -> str : ''' Returns a result message with further details about the error or successful response. ''' return self . _message","title":"msg()"},{"location":"typings/client/#interface.typings.client.RequestResult.status","text":"Returns the HTTP status code of the response. Returns '-1' if no request was made. Source code in interface/typings/client.py 32 33 34 35 36 def status ( self ) -> int : ''' Returns the HTTP status code of the response. Returns '-1' if no request was made. ''' return self . _status","title":"status()"},{"location":"typings/error/","text":"Error This is a generic error class. Source code in interface/typings/error.py 7 8 9 10 11 12 13 14 15 16 17 18 19 class Error : ''' This is a generic error class. ''' def __init__ ( self , msg : str ) -> None : self . _message = msg def string ( self ) -> str : ''' Returns the error message as a string. ''' return self . _message string () Returns the error message as a string. Source code in interface/typings/error.py 15 16 17 18 19 def string ( self ) -> str : ''' Returns the error message as a string. ''' return self . _message Result Bases: Generic [ R , E ] Result represents either R when there was no error or E when there was. Source code in interface/typings/error.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Result ( Generic [ R , E ]): ''' Result represents either `R` when there was no error or `E` when there was. ''' def __init__ ( self , res : R = None , err : E = None ) -> None : self . _res = res self . _err = err def is_ok ( self ) -> bool : ''' Returns if the result is okay. ''' return self . _res != None def is_err ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _err != None def unwrap ( self ) -> R : ''' Unpacks the the result. The user should check with `is_ok` before unpacking the result as this function will throw an exception. ''' if self . _res == None or self . _err != None : raise Exception ( 'Cannot unpack None result' ) return self . _res def error ( self ) -> E : ''' Returns the error if present otherwise `None`. ''' return self . _err error () Returns the error if present otherwise None . Source code in interface/typings/error.py 53 54 55 56 57 def error ( self ) -> E : ''' Returns the error if present otherwise `None`. ''' return self . _err is_err () Returns if the result is an error. Source code in interface/typings/error.py 37 38 39 40 41 def is_err ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _err != None is_ok () Returns if the result is okay. Source code in interface/typings/error.py 31 32 33 34 35 def is_ok ( self ) -> bool : ''' Returns if the result is okay. ''' return self . _res != None unwrap () Unpacks the the result. The user should check with is_ok before unpacking the result as this function will throw an exception. Source code in interface/typings/error.py 43 44 45 46 47 48 49 50 51 def unwrap ( self ) -> R : ''' Unpacks the the result. The user should check with `is_ok` before unpacking the result as this function will throw an exception. ''' if self . _res == None or self . _err != None : raise Exception ( 'Cannot unpack None result' ) return self . _res","title":"Error"},{"location":"typings/error/#interface.typings.error.Error","text":"This is a generic error class. Source code in interface/typings/error.py 7 8 9 10 11 12 13 14 15 16 17 18 19 class Error : ''' This is a generic error class. ''' def __init__ ( self , msg : str ) -> None : self . _message = msg def string ( self ) -> str : ''' Returns the error message as a string. ''' return self . _message","title":"Error"},{"location":"typings/error/#interface.typings.error.Error.string","text":"Returns the error message as a string. Source code in interface/typings/error.py 15 16 17 18 19 def string ( self ) -> str : ''' Returns the error message as a string. ''' return self . _message","title":"string()"},{"location":"typings/error/#interface.typings.error.Result","text":"Bases: Generic [ R , E ] Result represents either R when there was no error or E when there was. Source code in interface/typings/error.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Result ( Generic [ R , E ]): ''' Result represents either `R` when there was no error or `E` when there was. ''' def __init__ ( self , res : R = None , err : E = None ) -> None : self . _res = res self . _err = err def is_ok ( self ) -> bool : ''' Returns if the result is okay. ''' return self . _res != None def is_err ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _err != None def unwrap ( self ) -> R : ''' Unpacks the the result. The user should check with `is_ok` before unpacking the result as this function will throw an exception. ''' if self . _res == None or self . _err != None : raise Exception ( 'Cannot unpack None result' ) return self . _res def error ( self ) -> E : ''' Returns the error if present otherwise `None`. ''' return self . _err","title":"Result"},{"location":"typings/error/#interface.typings.error.Result.error","text":"Returns the error if present otherwise None . Source code in interface/typings/error.py 53 54 55 56 57 def error ( self ) -> E : ''' Returns the error if present otherwise `None`. ''' return self . _err","title":"error()"},{"location":"typings/error/#interface.typings.error.Result.is_err","text":"Returns if the result is an error. Source code in interface/typings/error.py 37 38 39 40 41 def is_err ( self ) -> bool : ''' Returns if the result is an error. ''' return self . _err != None","title":"is_err()"},{"location":"typings/error/#interface.typings.error.Result.is_ok","text":"Returns if the result is okay. Source code in interface/typings/error.py 31 32 33 34 35 def is_ok ( self ) -> bool : ''' Returns if the result is okay. ''' return self . _res != None","title":"is_ok()"},{"location":"typings/error/#interface.typings.error.Result.unwrap","text":"Unpacks the the result. The user should check with is_ok before unpacking the result as this function will throw an exception. Source code in interface/typings/error.py 43 44 45 46 47 48 49 50 51 def unwrap ( self ) -> R : ''' Unpacks the the result. The user should check with `is_ok` before unpacking the result as this function will throw an exception. ''' if self . _res == None or self . _err != None : raise Exception ( 'Cannot unpack None result' ) return self . _res","title":"unwrap()"},{"location":"typings/graph/","text":"","title":"Graph"},{"location":"typings/renderer/","text":"ArUcoMarker Bases: RenderObject This renders an ArUco marker at the specified loaction and scale. Source code in interface/typings/renderer.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class ArUcoMarker ( RenderObject ): ''' This renders an ArUco marker at the specified loaction and scale. ''' def __init__ ( self , x : int , y : int , marker : cv . Mat , name : str , scale : float = 1.0 ) -> None : super () . __init__ ( x , y , name , scale ) self . _src_marker = marker # This is the original marker self . _marker = marker # This is the current marker being used for rendering def update ( self , new_x : int , new_y : int ): ''' The marker position cannot be updated. ''' pass def render ( self , frame : cv . Mat ): ''' Render first scales the marker (if needed) and then inserts the pixels into the frame mat. ''' self . scale () frame [ self . _y : self . _y + self . _marker . shape [ 0 ], self . _x : self . _x + self . _marker . shape [ 1 ] ] = self . _marker def scale ( self ): ''' Scale the marker by calling super's scale method with the current and original marker mat. ''' self . _marker = super () . scale ( self . _marker , self . _src_marker ) render ( frame ) Render first scales the marker (if needed) and then inserts the pixels into the frame mat. Source code in interface/typings/renderer.py 97 98 99 100 101 102 103 104 105 def render ( self , frame : cv . Mat ): ''' Render first scales the marker (if needed) and then inserts the pixels into the frame mat. ''' self . scale () frame [ self . _y : self . _y + self . _marker . shape [ 0 ], self . _x : self . _x + self . _marker . shape [ 1 ] ] = self . _marker scale () Scale the marker by calling super's scale method with the current and original marker mat. Source code in interface/typings/renderer.py 107 108 109 110 111 def scale ( self ): ''' Scale the marker by calling super's scale method with the current and original marker mat. ''' self . _marker = super () . scale ( self . _marker , self . _src_marker ) update ( new_x , new_y ) The marker position cannot be updated. Source code in interface/typings/renderer.py 91 92 93 94 95 def update ( self , new_x : int , new_y : int ): ''' The marker position cannot be updated. ''' pass ArUcoMarkerTracking Bases: RenderObject This renders ArUco marker tracking debug information. This outlines the marker, draws a center dot and prints out the angle of the marker. Source code in interface/typings/renderer.py 114 115 116 117 118 119 120 121 class ArUcoMarkerTracking ( RenderObject ): ''' This renders ArUco marker tracking debug information. This outlines the marker, draws a center dot and prints out the angle of the marker. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : super () . __init__ ( x , y , name , scale ) ConfettiParticle Bases: RenderObject This renders a confetti particle. Source code in interface/typings/renderer.py 124 125 126 127 128 129 130 class ConfettiParticle ( RenderObject ): ''' This renders a confetti particle. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : super () . __init__ ( x , y , name , scale ) Node Bases: RenderObject This renders a node around a tracked (and detected) marker. Source code in interface/typings/renderer.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Node ( RenderObject ): ''' This renders a node around a tracked (and detected) marker. ''' def __init__ ( self , x : int , y : int , radius : int , name : str , color : Tuple [ int , int , int ]) -> None : super () . __init__ ( x , y , name , 1.0 ) self . _color : Tuple [ int , int , int ] = color self . _radius = radius def update ( self , new_x : int , new_y : int ): super () . update ( new_x , new_y ) def render ( self , frame : cv . Mat ): ''' Render a circle around the tracked marker. ''' cv . circle ( frame , ( self . _x , self . _y ), self . _radius , self . _color , 5 ) render ( frame ) Render a circle around the tracked marker. Source code in interface/typings/renderer.py 74 75 76 77 78 def render ( self , frame : cv . Mat ): ''' Render a circle around the tracked marker. ''' cv . circle ( frame , ( self . _x , self . _y ), self . _radius , self . _color , 5 ) RenderObject This is the base class of each RenderObject. It provides some shared attributes and methods. Source code in interface/typings/renderer.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class RenderObject : ''' This is the base class of each RenderObject. It provides some shared attributes and methods. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : self . _prev_scale = - 1 self . _scale = scale self . _name = name self . _x : int = x self . _y : int = y def update ( self , new_x : int , new_y : int ): ''' Update the position of the render object. ''' self . _x = new_x self . _y = new_y def render ( self , _ : cv . Mat ): ''' The default render method renders nothing. ''' pass def scale ( self , current_mat : cv . Mat , src_mat : cv . Mat ) -> cv . Mat : ''' Scale 'mat' by factor. ''' if self . _scale == 1.0 or self . _scale < 0 : return current_mat if self . _prev_scale == self . _scale : return current_mat self . _prev_scale = self . _scale return cv . resize ( src_mat , ( 0 , 0 ), fx = self . _scale , fy = self . _scale ) def set_scale ( self , scale : float ): ''' Set the scaling factor. ''' self . _scale = scale render ( _ ) The default render method renders nothing. Source code in interface/typings/renderer.py 35 36 37 38 39 def render ( self , _ : cv . Mat ): ''' The default render method renders nothing. ''' pass scale ( current_mat , src_mat ) Scale 'mat' by factor. Source code in interface/typings/renderer.py 41 42 43 44 45 46 47 48 49 50 51 52 def scale ( self , current_mat : cv . Mat , src_mat : cv . Mat ) -> cv . Mat : ''' Scale 'mat' by factor. ''' if self . _scale == 1.0 or self . _scale < 0 : return current_mat if self . _prev_scale == self . _scale : return current_mat self . _prev_scale = self . _scale return cv . resize ( src_mat , ( 0 , 0 ), fx = self . _scale , fy = self . _scale ) set_scale ( scale ) Set the scaling factor. Source code in interface/typings/renderer.py 54 55 56 57 58 def set_scale ( self , scale : float ): ''' Set the scaling factor. ''' self . _scale = scale update ( new_x , new_y ) Update the position of the render object. Source code in interface/typings/renderer.py 28 29 30 31 32 33 def update ( self , new_x : int , new_y : int ): ''' Update the position of the render object. ''' self . _x = new_x self . _y = new_y","title":"Renderer"},{"location":"typings/renderer/#interface.typings.renderer.ArUcoMarker","text":"Bases: RenderObject This renders an ArUco marker at the specified loaction and scale. Source code in interface/typings/renderer.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class ArUcoMarker ( RenderObject ): ''' This renders an ArUco marker at the specified loaction and scale. ''' def __init__ ( self , x : int , y : int , marker : cv . Mat , name : str , scale : float = 1.0 ) -> None : super () . __init__ ( x , y , name , scale ) self . _src_marker = marker # This is the original marker self . _marker = marker # This is the current marker being used for rendering def update ( self , new_x : int , new_y : int ): ''' The marker position cannot be updated. ''' pass def render ( self , frame : cv . Mat ): ''' Render first scales the marker (if needed) and then inserts the pixels into the frame mat. ''' self . scale () frame [ self . _y : self . _y + self . _marker . shape [ 0 ], self . _x : self . _x + self . _marker . shape [ 1 ] ] = self . _marker def scale ( self ): ''' Scale the marker by calling super's scale method with the current and original marker mat. ''' self . _marker = super () . scale ( self . _marker , self . _src_marker )","title":"ArUcoMarker"},{"location":"typings/renderer/#interface.typings.renderer.ArUcoMarker.render","text":"Render first scales the marker (if needed) and then inserts the pixels into the frame mat. Source code in interface/typings/renderer.py 97 98 99 100 101 102 103 104 105 def render ( self , frame : cv . Mat ): ''' Render first scales the marker (if needed) and then inserts the pixels into the frame mat. ''' self . scale () frame [ self . _y : self . _y + self . _marker . shape [ 0 ], self . _x : self . _x + self . _marker . shape [ 1 ] ] = self . _marker","title":"render()"},{"location":"typings/renderer/#interface.typings.renderer.ArUcoMarker.scale","text":"Scale the marker by calling super's scale method with the current and original marker mat. Source code in interface/typings/renderer.py 107 108 109 110 111 def scale ( self ): ''' Scale the marker by calling super's scale method with the current and original marker mat. ''' self . _marker = super () . scale ( self . _marker , self . _src_marker )","title":"scale()"},{"location":"typings/renderer/#interface.typings.renderer.ArUcoMarker.update","text":"The marker position cannot be updated. Source code in interface/typings/renderer.py 91 92 93 94 95 def update ( self , new_x : int , new_y : int ): ''' The marker position cannot be updated. ''' pass","title":"update()"},{"location":"typings/renderer/#interface.typings.renderer.ArUcoMarkerTracking","text":"Bases: RenderObject This renders ArUco marker tracking debug information. This outlines the marker, draws a center dot and prints out the angle of the marker. Source code in interface/typings/renderer.py 114 115 116 117 118 119 120 121 class ArUcoMarkerTracking ( RenderObject ): ''' This renders ArUco marker tracking debug information. This outlines the marker, draws a center dot and prints out the angle of the marker. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : super () . __init__ ( x , y , name , scale )","title":"ArUcoMarkerTracking"},{"location":"typings/renderer/#interface.typings.renderer.ConfettiParticle","text":"Bases: RenderObject This renders a confetti particle. Source code in interface/typings/renderer.py 124 125 126 127 128 129 130 class ConfettiParticle ( RenderObject ): ''' This renders a confetti particle. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : super () . __init__ ( x , y , name , scale )","title":"ConfettiParticle"},{"location":"typings/renderer/#interface.typings.renderer.Node","text":"Bases: RenderObject This renders a node around a tracked (and detected) marker. Source code in interface/typings/renderer.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Node ( RenderObject ): ''' This renders a node around a tracked (and detected) marker. ''' def __init__ ( self , x : int , y : int , radius : int , name : str , color : Tuple [ int , int , int ]) -> None : super () . __init__ ( x , y , name , 1.0 ) self . _color : Tuple [ int , int , int ] = color self . _radius = radius def update ( self , new_x : int , new_y : int ): super () . update ( new_x , new_y ) def render ( self , frame : cv . Mat ): ''' Render a circle around the tracked marker. ''' cv . circle ( frame , ( self . _x , self . _y ), self . _radius , self . _color , 5 )","title":"Node"},{"location":"typings/renderer/#interface.typings.renderer.Node.render","text":"Render a circle around the tracked marker. Source code in interface/typings/renderer.py 74 75 76 77 78 def render ( self , frame : cv . Mat ): ''' Render a circle around the tracked marker. ''' cv . circle ( frame , ( self . _x , self . _y ), self . _radius , self . _color , 5 )","title":"render()"},{"location":"typings/renderer/#interface.typings.renderer.RenderObject","text":"This is the base class of each RenderObject. It provides some shared attributes and methods. Source code in interface/typings/renderer.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class RenderObject : ''' This is the base class of each RenderObject. It provides some shared attributes and methods. ''' def __init__ ( self , x : int , y : int , name : str , scale : float ) -> None : self . _prev_scale = - 1 self . _scale = scale self . _name = name self . _x : int = x self . _y : int = y def update ( self , new_x : int , new_y : int ): ''' Update the position of the render object. ''' self . _x = new_x self . _y = new_y def render ( self , _ : cv . Mat ): ''' The default render method renders nothing. ''' pass def scale ( self , current_mat : cv . Mat , src_mat : cv . Mat ) -> cv . Mat : ''' Scale 'mat' by factor. ''' if self . _scale == 1.0 or self . _scale < 0 : return current_mat if self . _prev_scale == self . _scale : return current_mat self . _prev_scale = self . _scale return cv . resize ( src_mat , ( 0 , 0 ), fx = self . _scale , fy = self . _scale ) def set_scale ( self , scale : float ): ''' Set the scaling factor. ''' self . _scale = scale","title":"RenderObject"},{"location":"typings/renderer/#interface.typings.renderer.RenderObject.render","text":"The default render method renders nothing. Source code in interface/typings/renderer.py 35 36 37 38 39 def render ( self , _ : cv . Mat ): ''' The default render method renders nothing. ''' pass","title":"render()"},{"location":"typings/renderer/#interface.typings.renderer.RenderObject.scale","text":"Scale 'mat' by factor. Source code in interface/typings/renderer.py 41 42 43 44 45 46 47 48 49 50 51 52 def scale ( self , current_mat : cv . Mat , src_mat : cv . Mat ) -> cv . Mat : ''' Scale 'mat' by factor. ''' if self . _scale == 1.0 or self . _scale < 0 : return current_mat if self . _prev_scale == self . _scale : return current_mat self . _prev_scale = self . _scale return cv . resize ( src_mat , ( 0 , 0 ), fx = self . _scale , fy = self . _scale )","title":"scale()"},{"location":"typings/renderer/#interface.typings.renderer.RenderObject.set_scale","text":"Set the scaling factor. Source code in interface/typings/renderer.py 54 55 56 57 58 def set_scale ( self , scale : float ): ''' Set the scaling factor. ''' self . _scale = scale","title":"set_scale()"},{"location":"typings/renderer/#interface.typings.renderer.RenderObject.update","text":"Update the position of the render object. Source code in interface/typings/renderer.py 28 29 30 31 32 33 def update ( self , new_x : int , new_y : int ): ''' Update the position of the render object. ''' self . _x = new_x self . _y = new_y","title":"update()"},{"location":"typings/capture/aruco/","text":"","title":"Aruco"},{"location":"typings/capture/calibration/","text":"CalibrationMode Bases: Enum Source code in interface/typings/capture/calibration.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @unique class CalibrationMode ( Enum ): AUTO = auto () SEMI_AUTO = auto () MANUAL = auto () @staticmethod def from_str ( mode : str ) -> Result [ Self , Error ]: ''' Returns the enum from the provided string or returns an error if no corresponding enum exists. ''' match mode . lower (): case 'auto' : return Ok ( CalibrationMode . AUTO ) case 'semi' : return Ok ( CalibrationMode . SEMI_AUTO ) case 'manual' : return Ok ( CalibrationMode . MANUAL ) case _ : return Err ( Error ( 'Invalid mode' )) from_str ( mode ) staticmethod Returns the enum from the provided string or returns an error if no corresponding enum exists. Source code in interface/typings/capture/calibration.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @staticmethod def from_str ( mode : str ) -> Result [ Self , Error ]: ''' Returns the enum from the provided string or returns an error if no corresponding enum exists. ''' match mode . lower (): case 'auto' : return Ok ( CalibrationMode . AUTO ) case 'semi' : return Ok ( CalibrationMode . SEMI_AUTO ) case 'manual' : return Ok ( CalibrationMode . MANUAL ) case _ : return Err ( Error ( 'Invalid mode' ))","title":"Calibration"},{"location":"typings/capture/calibration/#interface.typings.capture.calibration.CalibrationMode","text":"Bases: Enum Source code in interface/typings/capture/calibration.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @unique class CalibrationMode ( Enum ): AUTO = auto () SEMI_AUTO = auto () MANUAL = auto () @staticmethod def from_str ( mode : str ) -> Result [ Self , Error ]: ''' Returns the enum from the provided string or returns an error if no corresponding enum exists. ''' match mode . lower (): case 'auto' : return Ok ( CalibrationMode . AUTO ) case 'semi' : return Ok ( CalibrationMode . SEMI_AUTO ) case 'manual' : return Ok ( CalibrationMode . MANUAL ) case _ : return Err ( Error ( 'Invalid mode' ))","title":"CalibrationMode"},{"location":"typings/capture/calibration/#interface.typings.capture.calibration.CalibrationMode.from_str","text":"Returns the enum from the provided string or returns an error if no corresponding enum exists. Source code in interface/typings/capture/calibration.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @staticmethod def from_str ( mode : str ) -> Result [ Self , Error ]: ''' Returns the enum from the provided string or returns an error if no corresponding enum exists. ''' match mode . lower (): case 'auto' : return Ok ( CalibrationMode . AUTO ) case 'semi' : return Ok ( CalibrationMode . SEMI_AUTO ) case 'manual' : return Ok ( CalibrationMode . MANUAL ) case _ : return Err ( Error ( 'Invalid mode' ))","title":"from_str()"},{"location":"utils/checks/","text":"is_between ( v , s , e , inclusive = False ) Returns if 'v' is between 's' and 'e'. If 'inclusive' is True 's' and 'e' are inclusive. Parameters: Name Type Description Default v int | float Value to check. required s int | float Start value. required e int | float End value. required Returns: Type Description bool If 'v' is between 's' and 'e'. Source code in interface/utils/checks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def is_between ( v : int | float , s : int | float , e : int | float , inclusive : bool = False ) -> bool : ''' Returns if 'v' is between 's' and 'e'. If 'inclusive' is True 's' and 'e' are inclusive. Args: v: Value to check. s: Start value. e: End value. Returns: If 'v' is between 's' and 'e'. ''' if inclusive : return v >= s and v <= e return v > s and v < e is_in ( v , l ) Returns if 'v' is in 'l'. Parameters: Name Type Description Default v any Value to check. required l list List of values to check against. required Returns: Type Description bool If 'v' is in 'l'. Source code in interface/utils/checks.py 1 2 3 4 5 6 7 8 9 10 11 12 def is_in ( v : any , l : list ) -> bool : ''' Returns if 'v' is in 'l'. Args: v: Value to check. l: List of values to check against. Returns: If 'v' is in 'l'. ''' return v in l","title":"Checks"},{"location":"utils/checks/#interface.utils.checks.is_between","text":"Returns if 'v' is between 's' and 'e'. If 'inclusive' is True 's' and 'e' are inclusive. Parameters: Name Type Description Default v int | float Value to check. required s int | float Start value. required e int | float End value. required Returns: Type Description bool If 'v' is between 's' and 'e'. Source code in interface/utils/checks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def is_between ( v : int | float , s : int | float , e : int | float , inclusive : bool = False ) -> bool : ''' Returns if 'v' is between 's' and 'e'. If 'inclusive' is True 's' and 'e' are inclusive. Args: v: Value to check. s: Start value. e: End value. Returns: If 'v' is between 's' and 'e'. ''' if inclusive : return v >= s and v <= e return v > s and v < e","title":"is_between()"},{"location":"utils/checks/#interface.utils.checks.is_in","text":"Returns if 'v' is in 'l'. Parameters: Name Type Description Default v any Value to check. required l list List of values to check against. required Returns: Type Description bool If 'v' is in 'l'. Source code in interface/utils/checks.py 1 2 3 4 5 6 7 8 9 10 11 12 def is_in ( v : any , l : list ) -> bool : ''' Returns if 'v' is in 'l'. Args: v: Value to check. l: List of values to check against. Returns: If 'v' is in 'l'. ''' return v in l","title":"is_in()"},{"location":"utils/colors/","text":"","title":"Colors"},{"location":"utils/fmt/","text":"fps_to_ms ( fps ) Convert FPS to a millisecond interval. Parameters: Name Type Description Default fps int Input FPS as integer. required Returns: Type Description int Interval in milliseconds as integer number. Source code in interface/utils/fmt.py 47 48 49 50 51 52 53 54 55 56 57 def fps_to_ms ( fps : int ) -> int : ''' Convert FPS to a millisecond interval. Args: fps: Input FPS as integer. Returns: Interval in milliseconds as integer number. ''' return math . floor (( 1 / fps ) * 1000 ) host_port_from ( host , port , secure = False ) Creates a http(s):// : string. Parameters: Name Type Description Default host str The IP address or domain of the host. required port int Port number. required secure bool If True https:// is prefixed, otherwise http://. False Returns: Type Description str The http(s):// : string. Source code in interface/utils/fmt.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def host_port_from ( host : str , port : int , secure : bool = False ) -> str : ''' Creates a http(s)://<host>:<port> string. Args: host: The IP address or domain of the host. port: Port number. secure: If True https:// is prefixed, otherwise http://. Returns: The http(s)://<host>:<port> string. ''' if not host : return '' if port < 1 or port > 65535 : return '' if secure : return f 'https:// { host } : { port } ' return f 'http:// { host } : { port } ' url_from ( base , paths ) Creates a complete URL with 'base' as the base url and each provided 'path' appended with a /. Parameters: Name Type Description Default base str The base URL. required paths tuple A variable number of path segments. required Returns: Type Description str Complete URL. Source code in interface/utils/fmt.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def url_from ( base : str , paths : tuple ) -> str : ''' Creates a complete URL with 'base' as the base url and each provided 'path' appended with a /. Args: base: The base URL. paths: A variable number of path segments. Returns: Complete URL. ''' url = base for p in paths : p = p . replace ( '/' , '' ) url = '/' . join ([ url , p . lower ()]) return url","title":"Fmt"},{"location":"utils/fmt/#interface.utils.fmt.fps_to_ms","text":"Convert FPS to a millisecond interval. Parameters: Name Type Description Default fps int Input FPS as integer. required Returns: Type Description int Interval in milliseconds as integer number. Source code in interface/utils/fmt.py 47 48 49 50 51 52 53 54 55 56 57 def fps_to_ms ( fps : int ) -> int : ''' Convert FPS to a millisecond interval. Args: fps: Input FPS as integer. Returns: Interval in milliseconds as integer number. ''' return math . floor (( 1 / fps ) * 1000 )","title":"fps_to_ms()"},{"location":"utils/fmt/#interface.utils.fmt.host_port_from","text":"Creates a http(s):// : string. Parameters: Name Type Description Default host str The IP address or domain of the host. required port int Port number. required secure bool If True https:// is prefixed, otherwise http://. False Returns: Type Description str The http(s):// : string. Source code in interface/utils/fmt.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def host_port_from ( host : str , port : int , secure : bool = False ) -> str : ''' Creates a http(s)://<host>:<port> string. Args: host: The IP address or domain of the host. port: Port number. secure: If True https:// is prefixed, otherwise http://. Returns: The http(s)://<host>:<port> string. ''' if not host : return '' if port < 1 or port > 65535 : return '' if secure : return f 'https:// { host } : { port } ' return f 'http:// { host } : { port } '","title":"host_port_from()"},{"location":"utils/fmt/#interface.utils.fmt.url_from","text":"Creates a complete URL with 'base' as the base url and each provided 'path' appended with a /. Parameters: Name Type Description Default base str The base URL. required paths tuple A variable number of path segments. required Returns: Type Description str Complete URL. Source code in interface/utils/fmt.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def url_from ( base : str , paths : tuple ) -> str : ''' Creates a complete URL with 'base' as the base url and each provided 'path' appended with a /. Args: base: The base URL. paths: A variable number of path segments. Returns: Complete URL. ''' url = base for p in paths : p = p . replace ( '/' , '' ) url = '/' . join ([ url , p . lower ()]) return url","title":"url_from()"},{"location":"utils/input/","text":"confirmation_prompt ( text , default = False ) This displays a confirmation prompt in which the user has to select 'y' or 'n'. Args:. text: The text message to display default: The default value returned. If None the user HAS to select either 'y' or 'n'. Returns: Type Description bool True if input is 'y' or False if input is 'n'. Source code in interface/utils/input.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def confirmation_prompt ( text : str , default : bool | None = False ) -> bool : ''' This displays a confirmation prompt in which the user has to select 'y' or 'n'. Args:. text: The text message to display default: The default value returned. If None the user HAS to select either 'y' or 'n'. Returns: True if input is 'y' or False if input is 'n'. ''' valid = False text = ' {} [ {} ]: ' . format ( text , \"y/n\" if default is None else ( \"Y/n\" if default else \"y/N\" )) while not valid : inp = input ( text ) . lower () if inp == '' and default != None : return default valid = inp in [ 'y' , 'n' ] return inp == 'y' handle_calibration ( cfg , mode ) Handle calibration flow. This first detects if a calibration jSON file exists. If this is not the case the user is asked to run the calibration. Denying this prompt exists the program. If a JSON file already exists the user is prompted if the file should be overwritten. If not, the existing JSON file gets used. Parameters: Name Type Description Default cfg Config Config data required Returns: Type Description Result [ CharucoCalibrationData , Error ] Calibration data or error Source code in interface/utils/input.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def handle_calibration ( cfg : Config , mode : str ) -> Result [ CharucoCalibrationData , Error ]: ''' Handle calibration flow. This first detects if a calibration jSON file exists. If this is not the case the user is asked to run the calibration. Denying this prompt exists the program. If a JSON file already exists the user is prompted if the file should be overwritten. If not, the existing JSON file gets used. Args: cfg: Config data Returns: Calibration data or error ''' # First we try to convert the provided mode (string) into an enum result = CalibrationMode . from_str ( mode ) if result . is_err (): return Err ( result . error ()) # Construct calib JSON file path calib_file_path = os . path . join ( cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) # Check if we already have a calib JSON file if not os . path . exists ( calib_file_path ): if confirmation_prompt ( 'No calibration file (.data/pckl.json) detected. Run calibration?' ): c = Calibration ( cfg ) return c . calibrate_save ( result . unwrap ()) if confirmation_prompt ( 'Calibration file exists. Re-run calibration?' ): c = Calibration ( cfg ) return c . calibrate_save ( result . unwrap ()) else : return read_calibration_result ( calib_file_path )","title":"Input"},{"location":"utils/input/#interface.utils.input.confirmation_prompt","text":"This displays a confirmation prompt in which the user has to select 'y' or 'n'. Args:. text: The text message to display default: The default value returned. If None the user HAS to select either 'y' or 'n'. Returns: Type Description bool True if input is 'y' or False if input is 'n'. Source code in interface/utils/input.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def confirmation_prompt ( text : str , default : bool | None = False ) -> bool : ''' This displays a confirmation prompt in which the user has to select 'y' or 'n'. Args:. text: The text message to display default: The default value returned. If None the user HAS to select either 'y' or 'n'. Returns: True if input is 'y' or False if input is 'n'. ''' valid = False text = ' {} [ {} ]: ' . format ( text , \"y/n\" if default is None else ( \"Y/n\" if default else \"y/N\" )) while not valid : inp = input ( text ) . lower () if inp == '' and default != None : return default valid = inp in [ 'y' , 'n' ] return inp == 'y'","title":"confirmation_prompt()"},{"location":"utils/input/#interface.utils.input.handle_calibration","text":"Handle calibration flow. This first detects if a calibration jSON file exists. If this is not the case the user is asked to run the calibration. Denying this prompt exists the program. If a JSON file already exists the user is prompted if the file should be overwritten. If not, the existing JSON file gets used. Parameters: Name Type Description Default cfg Config Config data required Returns: Type Description Result [ CharucoCalibrationData , Error ] Calibration data or error Source code in interface/utils/input.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def handle_calibration ( cfg : Config , mode : str ) -> Result [ CharucoCalibrationData , Error ]: ''' Handle calibration flow. This first detects if a calibration jSON file exists. If this is not the case the user is asked to run the calibration. Denying this prompt exists the program. If a JSON file already exists the user is prompted if the file should be overwritten. If not, the existing JSON file gets used. Args: cfg: Config data Returns: Calibration data or error ''' # First we try to convert the provided mode (string) into an enum result = CalibrationMode . from_str ( mode ) if result . is_err (): return Err ( result . error ()) # Construct calib JSON file path calib_file_path = os . path . join ( cfg [ 'capture' ][ 'path' ], 'calib.pckl' ) # Check if we already have a calib JSON file if not os . path . exists ( calib_file_path ): if confirmation_prompt ( 'No calibration file (.data/pckl.json) detected. Run calibration?' ): c = Calibration ( cfg ) return c . calibrate_save ( result . unwrap ()) if confirmation_prompt ( 'Calibration file exists. Re-run calibration?' ): c = Calibration ( cfg ) return c . calibrate_save ( result . unwrap ()) else : return read_calibration_result ( calib_file_path )","title":"handle_calibration()"},{"location":"utils/wait/","text":"multi_wait_or ( d , * keys ) Wait or do with multiple keys. Parameters: Name Type Description Default d int Duration to wait in milliseconds. required keys Keys to listen for. required Returns: Name Type Description pressed int Returns index > 0 if one of the provided keys were pressed, -1 otherwise. Source code in interface/utils/wait.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def multi_wait_or ( d : int , * keys : str ) -> int : ''' Wait or do with multiple keys. Args: d: Duration to wait in milliseconds. keys: Keys to listen for. Returns: pressed: Returns index > 0 if one of the provided keys were pressed, -1 otherwise. ''' code = cv . waitKey ( d ) for i , key in enumerate ( keys ): if code == ord ( key ): return i return - 1 wait_or ( d , key = 'q' ) Wait or do when key is pressed. Parameters: Name Type Description Default d int Duration to wait in milliseconds. required key str Key press to wait for. 'q' Returns: Name Type Description pressed bool Returns True if key was pressed, False otherwise. Source code in interface/utils/wait.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def wait_or ( d : int , key : str = 'q' ) -> bool : ''' Wait or do when `key` is pressed. Args: d: Duration to wait in milliseconds. key: Key press to wait for. Returns: pressed: Returns True if `key` was pressed, False otherwise. ''' code = cv . waitKey ( d ) if code == ord ( key ): return True return False","title":"Wait"},{"location":"utils/wait/#interface.utils.wait.multi_wait_or","text":"Wait or do with multiple keys. Parameters: Name Type Description Default d int Duration to wait in milliseconds. required keys Keys to listen for. required Returns: Name Type Description pressed int Returns index > 0 if one of the provided keys were pressed, -1 otherwise. Source code in interface/utils/wait.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def multi_wait_or ( d : int , * keys : str ) -> int : ''' Wait or do with multiple keys. Args: d: Duration to wait in milliseconds. keys: Keys to listen for. Returns: pressed: Returns index > 0 if one of the provided keys were pressed, -1 otherwise. ''' code = cv . waitKey ( d ) for i , key in enumerate ( keys ): if code == ord ( key ): return i return - 1","title":"multi_wait_or()"},{"location":"utils/wait/#interface.utils.wait.wait_or","text":"Wait or do when key is pressed. Parameters: Name Type Description Default d int Duration to wait in milliseconds. required key str Key press to wait for. 'q' Returns: Name Type Description pressed bool Returns True if key was pressed, False otherwise. Source code in interface/utils/wait.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def wait_or ( d : int , key : str = 'q' ) -> bool : ''' Wait or do when `key` is pressed. Args: d: Duration to wait in milliseconds. key: Key press to wait for. Returns: pressed: Returns True if `key` was pressed, False otherwise. ''' code = cv . waitKey ( d ) if code == ord ( key ): return True return False","title":"wait_or()"}]}